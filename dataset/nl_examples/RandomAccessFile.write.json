{"api": "RandomAccessFile.write", "question": "Why is RandomAccessFile writeLong implemented with multiple write calls?: While profiling an application I noticed that RandomAccessFile.writeLong was taking a lot of time.\n\nI checked the code for this method, and it involves eight calls of the native method write. I wrote an alternative implementation for writeLong using a byte[]. Something like this:\n\nRandomAccessFile randomAccessFile = new RandomAccessFile(\"out.dat\", \"rwd\");\n...\nbyte[] aux = new byte[8];\naux[0] = (byte) ((l >>> 56) & 0xFF);\naux[1] = (byte) ((l >>> 48) & 0xFF);\naux[2] = (byte) ((l >>> 40) & 0xFF);\naux[3] = (byte) ((l >>> 32) & 0xFF);\naux[4] = (byte) ((l >>> 24) & 0xFF);\naux[5] = (byte) ((l >>> 16) & 0xFF);\naux[6] = (byte) ((l >>> 8) & 0xFF);\naux[7] = (byte) ((l >>> 0) & 0xFF);\nrandomAccessFile.write(aux);\n", "code": "{\n    RandomAccessFile raf = new RandomAccessFile(\"test.dat\", \"rwd\");\n    int longCount = 10000;\n    long start = System.nanoTime();\n    for (long l = 0; l < longCount; l++)\n        raf.writeLong(l);\n    long time = System.nanoTime() - start;\n    System.out.printf(\"writeLong() took %,d us on average%n\", time / longCount / 1000);\n    raf.close();\n}\n{\n    RandomAccessFile raf = new RandomAccessFile(\"test2.dat\", \"rwd\");\n    int longCount = 10000;\n    long start = System.nanoTime();\n    byte[] aux = new byte[8];\n    try {\n        for (long l = 0; l < longCount; l++) {\n            aux[0] = (byte) (l >>> 56);\n            aux[1] = (byte) (l >>> 48);\n            aux[2] = (byte) (l >>> 40);\n            aux[3] = (byte) (l >>> 32);\n            aux[4] = (byte) (l >>> 24);\n            aux[5] = (byte) (l >>> 16);\n            aux[6] = (byte) (l >>> 8);\n            aux[7] = (byte) l;\n            \n            raf.write(aux);\n            \n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    long time = System.nanoTime() - start;\n    System.out.printf(\"write byte[8] took %,d us on average%n\", time / longCount / 1000);\n    raf.close();\n}", "explanation": "It appears that the RandomAccessFile.writeLong() doesn't minimise the number of calls to the OS. The cost increases dramatically by using \"rwd\" instead of \"rw\" which should be enough to indicate its not the calls themselves which cost the time. (its the fact the OS is try to commit every write to disk and the disk only spins so fast)", "origin": "stackoverflow.com/questions/5742427", "rule": "Write data to a RandomAccessFile using a byte array, subsequently close it, and if an Exception arises, handle it by catching the Exception.\n"}