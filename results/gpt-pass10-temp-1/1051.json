{
    "id": "chatcmpl-8HgDmPpakZtPUJzrCe3G0aZPPMcG0",
    "object": "chat.completion",
    "created": 1699224566,
    "model": "gpt-3.5-turbo-0613",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public static ArrayList<String> matchCommands(String[][] grid, String[] cmdTokens) {\n    ArrayList<String> matchedCommands = new ArrayList<String>();\n\n    int depthMark = 0;\n    int col = 0;\n    for (col = 0; col < cmdTokens.length && depthMark < grid[0].length; col++) {\n        String token = cmdTokens[col];\n        List<String> likeMatches = new ArrayList<String>();\n        for (int row = 0; row < grid.length; row++) {\n            if (grid[row][col].startsWith(token)) {\n                likeMatches.add(grid[row][col]);\n            }\n        }\n        if (likeMatches.isEmpty()) {\n            break;\n        }\n        matchedCommands.clear();\n        matchedCommands.addAll(likeMatches);\n        depthMark++;\n    }\n\n    if (col < cmdTokens.length) {\n        matchedCommands.clear();\n    }\n\n    return matchedCommands;\n}\n\npublic static void main(String[] args) {\n    String[][] cmdGrid = {\n        {\"mysql\", \"dump\", \"grid\", \"se314\"},\n        {\"mysql\", \"connect\", \"grid\"},\n        {\"mysql\", \"dump\", \"grid\"},\n        {\"mysql\", \"connect\", \"rds\"}\n    };\n\n    String[] cmdTokens = {\"my\", \"du\", \"gr\"};\n\n    ArrayList<String> matchedCommands = matchCommands(cmdGrid, cmdTokens);\n\n    System.out.println(\"Possible matched commands:\");\n    for (String command : matchedCommands) {\n        System.out.println(command);\n    }\n}\n<<<explanation>>>: The code defines a method called matchCommands that takes an input grid containing commands and their tokens, and a list of command tokens to match against. The method iterates through the command tokens and matches them against the corresponding columns in the grid. It uses a depthMark variable to keep track of the current column being matched, and a col variable to keep track of the current command token being matched.\n\nThe method creates a list called matchedCommands to store the matched commands. It iterates through the command tokens and for each token, it checks if there is a partial match in the grid. If there is, it adds all the matched commands to the likeMatches list. If there are no matches, it breaks out of the loop.\n\nIf there are matches, it updates the matchedCommands list with the likeMatches list and increments the depthMark. This allows the method to match consecutive columns in the grid.\n\nFinally, the method checks if the loop ended prematurely (i.e. not all command tokens were matched). If so, it clears the matchedCommands list.\n\nIn the main method, an example grid and command tokens are defined. The matchCommands method is called with these inputs, and the result is printed to the console.\n\nThis code provides a basic implementation of matching command tokens against a grid of commands. It can be extended to handle more complex matching rules or to provide additional feedback to the user."
            },
            "finish_reason": "stop"
        },
        {
            "index": 1,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public static String findMatchingCommand(String[][] grid, String[] cmdTokens) {\n    StringBuilder command = new StringBuilder();\n\n    for (int i = 0; i < cmdTokens.length; i++) {\n        String token = cmdTokens[i];\n\n        // Find rows that match wildcard in column 0\n        List<String[]> matchingRows = new ArrayList<>();\n        for (String[] row : grid) {\n            if (row[0].startsWith(token)) {\n                matchingRows.add(row);\n            }\n        }\n\n        // If no matching rows found, return \"unknown\"\n        if (matchingRows.isEmpty()) {\n            return \"unknown\";\n        }\n\n        // If only one matching row found, append remaining columns to command\n        if (matchingRows.size() == 1) {\n            for (int j = i + 1; j < row.length; j++) {\n                command.append(row[j]).append(\" \");\n            }\n            return command.toString().trim();\n        }\n\n        // If more than one matching row found, continue to next token\n    }\n\n    // If all tokens processed and more than one matching row found for last token\n    return \"ambiguous\";\n}\n\npublic static void main(String[] args) {\n    String[][] grid = makeGrid(strs, false);\n    String[] cmdTokens = {\"my\", \"co\", \"gr\"};\n    String command = findMatchingCommand(grid, cmdTokens);\n    System.out.println(command);\n}\n<<<explanation>>>: The code iterates through the cmdTokens and finds all the rows that match the wildcard in the first column. If there are no matching rows, it returns \"unknown\". If there is only one matching row, it appends the remaining columns to the command and returns it. If there are multiple matching rows, it continues to the next token. If all tokens are processed and there are still multiple matching rows for the last token, it returns \"ambiguous\". The main method demonstrates how to use the code with the makeGrid method to create the grid and the cmdTokens array to represent the user's input."
            },
            "finish_reason": "stop"
        },
        {
            "index": 2,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public static String[][] getDistinctValues(String[][] grid, String cmdToken) {\nList<String[]> distinctValues = new ArrayList<>();\nfor (String[] row : grid) {\nif (row[0].startsWith(cmdToken) && !distinctValues.contains(row)) {\ndistinctValues.add(row);\n}\n}\nreturn distinctValues.toArray(new String[distinctValues.size()][]);\n}\n\npublic static void main(String[] args) {\nString[][] grid = {{\"mysql\", \"dump\", \"grid\", \"se314\"},\n    {\"mysql\", \"connect\", \"grid\"},\n    {\"mysql\", \"dump\", \"grid\"},\n    {\"mysql\", \"connect\", \"rds\"}};\n\nString cmdToken = \"my\";\nString[][] distinctValues = getDistinctValues(grid, cmdToken);\nfor (String[] row : distinctValues) {\nSystem.out.println(Arrays.toString(row));\n}\n}\n<<<explanation>>>: The getDistinctValues() method takes a 2-dimensional array and a command token as parameters. It iterates through each row of the grid, checking if the first element of the row starts with the command token and if the row is not already in the list of distinct values. If both conditions are met, the row is added to the distinct values list. Finally, the method returns the distinct values as a 2-dimensional array.\n\nIn the main method, we create a sample grid and specify a command token. We then call the getDistinctValues() method with the grid and command token as arguments. The distinct values are printed to the console."
            },
            "finish_reason": "stop"
        },
        {
            "index": 3,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public static List<List<String>> filterGrid(String[][] grid, String[] cmdTokens) {\n    List<List<String>> filteredGrid = new ArrayList<>();\n\n    for (int i = 0; i < grid.length; i++) {\n        boolean match = true;\n        for (int j = 0; j < cmdTokens.length; j++) {\n            if (j >= grid[i].length || !grid[i][j].startsWith(cmdTokens[j])) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            List<String> row = Arrays.asList(grid[i]);\n            filteredGrid.add(row);\n        }\n    }\n\n    return filteredGrid;\n}\n\npublic static void main(String[] args) {\n    String[][] grid = {\n            {\"mysql\", \"dump\", \"grid\", \"se314\"},\n            {\"mysql\", \"connect\", \"grid\"},\n            {\"mysql\", \"dump\", \"grid\"},\n            {\"mysql\", \"connect\", \"rds\"}\n    };\n    String[] cmdTokens = {\"my\", \"du\", \"gr\"};\n\n    List<List<String>> filteredGrid = filterGrid(grid, cmdTokens);\n\n    for (List<String> row : filteredGrid) {\n        System.out.println(row);\n    }\n}\n<<<explanation>>>: The function filterGrid takes a 2D array (grid) and an array of command tokens (cmdTokens) as input and filters the grid based on the command tokens. It returns a list of lists containing the filtered rows from the grid.\n\nThe function iterates over each row of the grid and checks if it matches the command tokens. It checks the length of the row to avoid an IndexOutOfBoundsException and uses the startsWith method to perform a wildcard match on each token. If a row matches the command tokens, it is added to the filteredGrid list.\n\nIn the main method, a sample grid and command tokens are provided. The filterGrid function is called with these inputs and the filtered rows are printed to the console."
            },
            "finish_reason": "stop"
        },
        {
            "index": 4,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public static List<String> getDistinctValues(String[][] grid, String wildcard, int column) {\n    List<String> distinctValues = new ArrayList<>();\n    for (int i = 0; i < grid.length; i++) {\n        String value = grid[i][column];\n        if (value.startsWith(wildcard) && !distinctValues.contains(value)) {\n            distinctValues.add(value);\n        }\n    }\n    return distinctValues;\n}\n\npublic static void main(String[] args) {\n    String[][] grid = {\n            {\"mysql\", \"dump\", \"grid\", \"se314\"},\n            {\"mysql\", \"connect\", \"grid\"},\n            {\"mysql\", \"dump\", \"grid\"},\n            {\"mysql\", \"connect\", \"rds\"}\n    };\n\n    List<String> distinctValues = getDistinctValues(grid, \"my\", 0);\n    for (String value : distinctValues) {\n        System.out.println(value);\n    }\n}\n<<<explanation>>>: The method getDistinctValues() takes a 2-dimensional array (grid), a wildcard string, and a column index as input. It iterates over the grid and checks if the value in the specified column starts with the wildcard string. If it does and the value is not already in the distinctValues list, it adds the value to the list. Finally, the distinctValues list is printed in the main method. This allows you to retrieve distinct values from a specific column in the grid based on a wildcard match."
            },
            "finish_reason": "stop"
        },
        {
            "index": 5,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public static void main(String[] args) {\n    String[][] cmdGrid = {{\"mysql\", \"dump\", \"grid\", \"se314\"}, {\"mysql\", \"connect\", \"grid\"}, {\"mysql\", \"dump\", \"grid\"}, {\"mysql\", \"connect\", \"rds\"}};\n    String cmdToken1 = \"my\";\n    String cmdToken2 = \"du\";\n    String cmdToken3 = \"gr\";\n\n    for (String[] row : cmdGrid) {\n        if (row[0].startsWith(cmdToken1) && row[1].startsWith(cmdToken2)) {\n            System.out.println(row[0] + \" \" + row[1]);\n        }\n    }\n}\n<<<explanation>>>: In this code, we iterate through the cmdGrid array and check if the first element in each row starts with cmdToken1 and the second element starts with cmdToken2. If both conditions are true, we print the first and second elements of the row. This approach allows you to filter the array based on the wildcard matches you described."
            },
            "finish_reason": "stop"
        },
        {
            "index": 6,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public static List<String> getDistinctValues(String[][] grid, String[] cmdTokens) {\n    List<String> distinctValues = new ArrayList<>();\n\n    for (int row = 0; row < grid.length; row++) {\n        boolean match = true;\n        for (int col = 0; col < cmdTokens.length; col++) {\n            String token = cmdTokens[col];\n            String value = grid[row][col];\n\n            if (!value.startsWith(token)) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            distinctValues.add(grid[row][cmdTokens.length]);\n        }\n    }\n\n    return distinctValues;\n}\n\npublic static void main(String[] args) {\n    String[][] grid = {\n        {\"mysql\", \"dump\", \"grid\", \"se314\"},\n        {\"mysql\", \"connect\", \"grid\"},\n        {\"mysql\", \"dump\", \"grid\"},\n        {\"mysql\", \"connect\", \"rds\"}\n    };\n\n    String[] cmdTokens = {\"my\", \"du\", \"gr\"};\n\n    List<String> distinctValues = getDistinctValues(grid, cmdTokens);\n    for (String value : distinctValues) {\n        System.out.println(value);\n    }\n}\n<<<explanation>>>: In the code, the getDistinctValues() method takes a 2-dimensional array grid and an array of command tokens cmdTokens. It iterates over each row in the grid and compares the values in each column with the corresponding token. If all tokens match the corresponding values, the value in the column after the tokens (colTokens.length) is added to the distinctValues list. Finally, the distinctValues are printed out in the main method. This method provides a way to extract distinct values based on the provided command tokens."
            },
            "finish_reason": "stop"
        },
        {
            "index": 7,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public static String[][] getDistinctValues(String[][] grid, String[] cmdTokens) {\n    List<String[]> distinctValues = new ArrayList<>();\n\n    for (String[] row : grid) {\n        if (row[0].startsWith(cmdTokens[0]) && row[1].startsWith(cmdTokens[1])) {\n            boolean hasMatch = false;\n            for (String[] existingRow : distinctValues) {\n                if (Arrays.equals(row, existingRow)) {\n                    hasMatch = true;\n                    break;\n                }\n            }\n            if (!hasMatch) {\n                distinctValues.add(row);\n            }\n        }\n    }\n\n    String[][] result = new String[distinctValues.size()][grid[0].length];\n    distinctValues.toArray(result);\n\n    return result;\n}\n\npublic static void main(String[] args) {\n    String[][] grid = {{\"mysql\", \"dump\", \"grid\", \"se314\"},\n                        {\"mysql\", \"connect\", \"grid\"},\n                        {\"mysql\", \"dump\", \"grid\"},\n                        {\"mysql\", \"connect\", \"rds\"}};\n    String[] cmdTokens = {\"my\", \"du\"};\n    String[][] distinctValues = getDistinctValues(grid, cmdTokens);\n\n    for (String[] row : distinctValues) {\n        System.out.println(Arrays.toString(row));\n    }\n}}\n<<<explanation>>>: The `getDistinctValues()` method takes a 2-dimensional array and an array of command tokens. It iterates over each row in the grid and checks if the first two columns match the command tokens. If there is no match for the current row in the distinct values list, it adds it to the list. Finally, it converts the distinct values list to a 2-dimensional array and returns it.\n\nIn the `main()` method, I have provided sample data for the grid and command tokens. The `getDistinctValues()` method is called with the grid and command tokens, and the resulting distinct values are printed to the console."
            },
            "finish_reason": "stop"
        },
        {
            "index": 8,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public static String[] parseCommand(String input) {\n     StringTokenizer st = new StringTokenizer(input, \" -\");\n     List<String> tokens = new ArrayList<>();\n\n     while (st.hasMoreTokens()) {\n         tokens.add(st.nextToken());\n     }\n\n     return tokens.toArray(new String[0]);\n}\n\npublic static String[][] filterGrid(String[][] grid, String[] command) {\n    List<String[]> filteredGrid = new ArrayList<>();\n\n    for (String[] row : grid) {\n        boolean match = true;\n        for (int i = 0; i < command.length; i++) {\n            if (!row[i].startsWith(command[i])) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            filteredGrid.add(row);\n        }\n    }\n\n    return filteredGrid.toArray(new String[0][]);\n}\n\npublic static void main(String[] args) {\n    String[][] cmdGrid = makeGrid(strs, false);\n    String[] command = parseCommand(\"my co gr\");\n    String[][] filteredGrid = filterGrid(cmdGrid, command);\n\n    for (String[] row : filteredGrid) {\n        for (String token : row) {\n            System.out.print(token + \" \");\n        }\n        System.out.println();\n    }\n}\n<<<explanation>>>: The code provided is a possible solution to your problem. The parseCommand() method takes in an input string and uses StringTokenizer to extract tokens separated by spaces and dashes. The filterGrid() method takes in the parsed command and the grid, and filters the grid based on matching tokens. The result is a filtered grid that can be further processed or displayed."
            },
            "finish_reason": "stop"
        },
        {
            "index": 9,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public static String[] tokenize(String filename, String delimiter) {\n    List<String> tokensList = new ArrayList<>();\n    StringTokenizer st = new StringTokenizer(filename, delimiter);\n    while (st.hasMoreTokens()) {\n        tokensList.add(st.nextToken());\n    }\n    String[] tokens = new String[tokensList.size()];\n    tokensList.toArray(tokens);\n    return tokens;\n}\n\npublic static String[][] makeGrid(String[] filenames, boolean bPrint) {\n    List<String[]> gridList = new ArrayList<>();\n    int maxCols = 0;\n    int gridRow = 0;\n    \n    for (String filename : filenames) {\n        if (!filename.endsWith(\".cmd\") && filename.contains(\"-\")) {\n            String[] tokens = tokenize(filename, \"-\");\n            int cols = tokens.length;\n            \n            if (cols > maxCols) {\n                maxCols = cols;\n            }\n            \n            String[] row = new String[cols];\n            System.arraycopy(tokens, 0, row, 0, cols);\n            gridList.add(row);\n            \n            if (bPrint) {\n                for (String token : tokens) {\n                    System.out.print(\" \" + token);\n                }\n                System.out.println(\"\");\n            }\n            \n            gridRow++;\n        }\n    }\n    \n    String[][] cmdGrid = new String[gridRow][maxCols];\n    cmdGrid = gridList.toArray(cmdGrid);\n    \n    return cmdGrid;\n}\n\npublic static List<String> getDistinctValues(String[][] grid, String[] cmdTokens) {\n    List<String> distinctValues = new ArrayList<>();\n    int depthmark = 0;\n    \n    for (int col = 0; col < cmdTokens.length; col++) {\n        String cmdToken = cmdTokens[col];\n        depthmark = col;\n        boolean exactMatchFound = false;\n        \n        for (String[] row : grid) {\n            String value = row[depthmark];\n            \n            if (value.startsWith(cmdToken) && !distinctValues.contains(value)) {\n                distinctValues.add(value);\n                \n                if (col == cmdTokens.length - 1 && row.length > depthmark + 1) {\n                    distinctValues.addAll(Arrays.asList(row).subList(depthmark + 1, row.length));\n                }\n                \n                if (col == cmdTokens.length - 1 && row.length == depthmark + 1) {\n                    exactMatchFound = true;\n                }\n            }\n        }\n        \n        if (exactMatchFound) {\n            break;\n        }\n    }\n    \n    return distinctValues;\n}\n\npublic static void main(String[] args) {\n    String[] filenames = {\"mysql dump grid se314\", \"mysql connect grid\", \"mysql dump grid\", \"mysql connect rds\"};\n    boolean bPrint = true;\n    String[][] cmdGrid = makeGrid(filenames, bPrint);\n    \n    String[] cmdTokens = {\"my\", \"du\", \"gr\"};\n    List<String> distinctValues = getDistinctValues(cmdGrid, cmdTokens);\n    \n    System.out.println(distinctValues);\n}\n<<<explanation>>>: The code first defines a method `tokenize()` that uses `StringTokenizer` to tokenize a given filename using a delimiter. The method `makeGrid()` then iterates over the filenames and tokenizes each filename using the provided delimiter. It constructs a 2-dimensional array grid, discarding filenames that end with \".cmd\" and filtering for filenames that contain a dash (\"-\"). Each row in the grid represents a tokenized filename.\n\nThe `getDistinctValues()` method receives the grid and an array of command tokens. It iterates over the command tokens and for each token, it finds distinct values in the grid that match the token at the corresponding depthmark. It keeps track of the depthmark, ensuring that an exact match is found if the last command token is reached, and adds the distinct values to a list. The method returns the list of distinct values.\n\nIn the main method, a sample array of filenames is provided, and the `makeGrid()` method is called to construct the grid. Then, a sample array of command tokens is provided, and the `getDistinctValues()` method is called to retrieve the distinct values matching the command tokens. Finally, the distinct values are printed to the console."
            },
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 1506,
        "completion_tokens": 4253,
        "total_tokens": 5759
    },
    "prompt": "Please answer my code questions using the given API following this format: <<<api>>>: $API\n<<<code>>>: $CODE\n<<<explanation>>>: $EXPLANATION.\nQuestion: Java StringTokenizer.nextToken() skips over empty fields:I am using a tab (/t) as delimiter and I know there are some empty fields in my data e.g.:\n\none->two->->three\nWhere -> equals the tab. As you can see an empty field is still correctly surrounded by tabs. Data is collected using a loop :\n\n while ((strLine = br.readLine()) != null) {\n    StringTokenizer st = new StringTokenizer(strLine, \"\t\");\n    String test = st.nextToken();\n    ...\n    }\nYet Java ignores this \"empty string\" and skips the field.\n\nIs there a way to circumvent this behaviour and force java to read in empty fields anyway?\nPlease using this api: StringTokenizer.nextToken.\nAnswer:<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public class TestStringTokenStrict {\n\n/**\n * Strict implementation of StringTokenizer\n * \n * @param str\n * @param delim\n * @param strict\n *            true = include NULL Token\n * @return\n */\nstatic StringTokenizer getStringTokenizerStrict(String str, String delim, boolean strict) {\n    StringTokenizer st = new StringTokenizer(str, delim, strict);\n    StringBuffer sb = new StringBuffer();\n\n    while (st.hasMoreTokens()) {\n        String s = st.nextToken();\n        if (s.equals(delim)) {\n            sb.append(\" \").append(delim);\n        } else {\n            sb.append(s).append(delim);\n            if (st.hasMoreTokens())\n                st.nextToken();\n        }\n    }\n    return (new StringTokenizer(sb.toString(), delim));\n}\n\nstatic void altStringTokenizer(StringTokenizer st) {\n    while (st.hasMoreTokens()) {\n        String type = st.nextToken();\n        String one = st.nextToken();\n        String two = st.nextToken();\n        String three = st.nextToken();\n        String four = st.nextToken();\n        String five = st.nextToken();\n\n        System.out.println(\n                \"[\" + type + \"] [\" + one + \"] [\" + two + \"] [\" + three + \"] [\" + four + \"] [\" + five + \"]\");\n    }\n}\n\npublic static void main(String[] args) {\n    String input = \"Record|One||Three||Five\";\n    altStringTokenizer(getStringTokenizerStrict(input, \"|\", true));\n}}\n<<<explanation>>>: The object your method decompressGZIP() needs is a byte[].\n\nSo the basic, technical answer to the question you have asked is:\nQuestion: Java Shell wildcard tokenizer: :My Java is extremely rusty and I'm stuck trying to make a user interface that simplifies the execution of shell scripts or batch files depending on whether it's Linus or Win32  respectively. The files have the following naming convention.  module-verb-object-etc [args-list]  mysql-connect-grid  mysql-connect-rds  mysql-dump-grid  mysql-dump-grid-se314ultimately I would like it to parse unambiguous terms so I can:tokenize the commands (e.g delimited by \"-\") & shorten them into simplified terms soemthing like foxpro's command window or cisco's IOS  (eg \"my co gr\" executes \"mysql-connect-grid\" in unix and *.cmd in win32)and also in the style of IOS allow the user to enter abbreviated commands so that they can type in  a question mark (?) and it will give them a hint as to the unique remaining (or next) command options (e.g. \"my?\" returns mysql  & \"my ?\" returns connect, or dump). Othr return values would be \"ambiguous\" or \"unknown\" for commands that are not unique or could not be matched. It may seem trivial but there are many hundreds of commands in each folder and my users don't want to think... I wrote a function to pull the list of files from a directory & retun an array of fileanmes. Then I convert that into a 2 dimensional array using the method below which returns a dynamicly sized grid of potential commands.    /**********************************************************************************     *  MAKE GRID: Parses array of filenames and tokenizes AWS cmds.     * @param strs  Array of filenames     **********************************************************************************/     public static String [][] makeGrid(String strs[], boolean bPrint) {       String tmpGrid[][];       int nMaxCols = 0;       int nRows = uniqueCount(strs);       int nGridRow = 0;        tmpGrid = new String [nRows][];        for (int nRow=0; nRow<nRows; nRow++) {  String cFilename = strs[nRow];                if (!cFilename.endsWith(\".cmd\") // just list unix files (filter for batch files)    && cFilename.indexOf(\"-\") > 0 ) // make sure there's a dash in the filename    {           String strTokens[] = tokenize(strs[nRow], \"-\"); // the dash is our token deliminator           int nCols = strTokens.length;            if (nCols>nMaxCols) nMaxCols=nCols;           tmpGrid[nGridRow] = new String [nCols];           for (int nCol=0; nCol<nCols; nCol++) {                tmpGrid[nGridRow][nCol] = strTokens[nCol];               if (bPrint) System.out.print(\" \"+tmpGrid[nGridRow][nCol]);             }            nGridRow++;            if (bPrint) System.out.println(\"\");     } //end-if         }       String[][] cmdGrid = new String[nGridRow][nMaxCols];       System.arraycopy(tmpGrid, 0, cmdGrid, 0, nGridRow); // removes null rows  (&NPEs!)       return cmdGrid;      }This returns a 2-d array (below), so grid[Row-N][Col-0] is a match. I'd like to pull only distinct values where row[0] is a wildcard match for cmdToken[0] && row[1] is \"like\" cmdToken[1] so that my users can piece together a command until \"my du gr ?\" returns \"ENTER, [se314]\" - if that makes sense...String[][] makeGrid:    mysql dump grid se314    mysql connect grid    mysql dump grid    mysql connect rdsMy Challenge: I cant seem to get my head around my matcher function in java. If it was SQL it would be something like: \"SELECT DISTINCT col2 FROM cmd_Grid   WHERE col1 LIKE 'cmdToken1%' \" or even better: recursively setting a int depthmark for each consecutive column`SELECT DISTINCT col+str(depthmark+1) FROM cmd_Grid     WHERE col+str(depthmark) LIKE 'cmdMatchedTokens%' \" until you have an exact match. I found a package called joSQL that I tried out of desperation but I cant seem to get it to work in Java6. Anyway: I was also hoping for a pure java solution so that everything could be contained in a single class... Maybe using scanner or something to parse my multidimentional array for unique values... I know I'm probably making it way more complex than it needs to be. a gentle nudge in the right direction would be appreciated.TIA\nPlease using this api: StringTokenizer.nextToken.\nAnswer:"
}