{
    "id": "chatcmpl-8HgNdH6YzRKVD6qQS0LhB4JFRqaEx",
    "object": "chat.completion",
    "created": 1699225177,
    "model": "gpt-3.5-turbo-0613",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>:   while ((line = br.readLine()) != null)        {\n            StringTokenizer st = new StringTokenizer(line, \" \");\n            element = st.nextToken().split(\" \");\n            // Rest of your code...\n        }\n<<<explanation>>>: In your code, you are using the split() method to split each line into an array of elements based on a space delimiter. However, when you parse the line \"3    50\", it is not splitting correctly because there are multiple spaces between the two numbers. \n\nTo fix this, you can use the StringTokenizer class to tokenize each line based on a space delimiter and then split the token into an array. This will handle multiple spaces as a single delimiter."
            },
            "finish_reason": "stop"
        },
        {
            "index": 1,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public class ReportGenerator {\n\n    public static void main(String[] args) {\n        BufferedReader br = null;\n        BufferedWriter bw = null;\n\n        try {\n            br = new BufferedReader(new FileReader(\"C:\\\\sprocketorders.txt\"));\n            String line;\n            String element[] = new String[2];\n            int sum[] = new int[5];\n            File file = new File(\"C:\\\\sprocketordersreport.txt\");\n            \n            while ((line = br.readLine()) != null) {\n                StringTokenizer st = new StringTokenizer(line, \" \");\n                element[0] = st.nextToken();\n                element[1] = st.nextToken();\n                \n                switch (Integer.parseInt(element[0])) {\n                    case 1:\n                        sum[0] = sum[0] + Integer.parseInt(element[1]);\n                        break;\n                    case 2:\n                        sum[1] = sum[1] + Integer.parseInt(element[1]);\n                        break;\n                    case 3:\n                        sum[2] = sum[2] + Integer.parseInt(element[1]);\n                        break;\n                    case 4:\n                        sum[3] = sum[3] + Integer.parseInt(element[1]);\n                        break;\n                    case 5:\n                        sum[4] = sum[4] + Integer.parseInt(element[1]);\n                        break;\n                }\n\n            }\n\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n\n            FileWriter fw = new FileWriter(file.getAbsoluteFile());\n            bw = new BufferedWriter(fw);\n            bw.write(\"Spacely Sprockets\\nTaking Sprockets into the Future\\nSales Summary Report\\nSprocket Number Total Quantity Sold\\n\");\n\n            for (int i = 0; i < sum.length; i++) {\n                bw.write((i + 1) + \"\\t\" + sum[i] + \"\\n\");\n            }\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (br != null)\n                    br.close();\n\n                if (bw != null)\n                    bw.close();\n\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n<<<explanation>>>: The exception `java.lang.NumberFormatException` is thrown when you are trying to convert a string to a number but the string does not have the correct format. \n\nIn your case, the line causing the exception is `switch(Integer.parseInt(element[0]))`. The error message indicates that the input string is `\"3    50\"`.\n\nThe reason for the exception is that your input file has multiple spaces between the two numbers. So when you split the line using a space delimiter, you end up with `\"3\"` and `\"    50\"`, where `\"    50\"` contains multiple spaces.\n\nTo fix this issue, you can modify your code to use `StringTokenizer` to split the line and ignore the excess spaces:\n\n```java\nwhile ((line = br.readLine()) != null) {\n    StringTokenizer st = new StringTokenizer(line, \" \");\n    element[0] = st.nextToken();\n    element[1] = st.nextToken();\n    \n    // rest of your code\n}\n```\n\nBy using `StringTokenizer`, you can split the line using a space as the delimiter and `nextToken()` will automatically handle the excess spaces, giving you the correct values for `element[0]` and `element[1]`."
            },
            "finish_reason": "stop"
        },
        {
            "index": 2,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>:\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\npublic class ReportGenerator {\n\n  public static void main(String[] args) {\n    BufferedReader br = null;\n    BufferedWriter bw = null;\n\n    try {\n      br = new BufferedReader(new FileReader(\"C:\\\\sprocketorders.txt\"));\n      String line;\n      String element[] = new String[2];\n      int sum[] = new int[5];\n      File file = new File(\"C:\\\\sprocketordersreport.txt\");\n\n      while ((line = br.readLine()) != null) {\n        StringTokenizer st = new StringTokenizer(line, \" \");\n        element[0] = st.nextToken();\n        element[1] = st.nextToken();\n        \n        switch (Integer.parseInt(element[0])) {\n          case 1:\n            sum[0] = sum[0] + Integer.parseInt(element[1]);\n            break;\n          case 2:\n            sum[1] = sum[1] + Integer.parseInt(element[1]);\n            break;\n          case 3:\n            sum[2] = sum[2] + Integer.parseInt(element[1]);\n            break;\n          case 4:\n            sum[3] = sum[3] + Integer.parseInt(element[1]);\n            break;\n          case 5:\n            sum[4] = sum[4] + Integer.parseInt(element[1]);\n            break;\n        }\n      }\n\n      if (!file.exists()) {\n        file.createNewFile();\n      }\n\n      FileWriter fw = new FileWriter(file.getAbsoluteFile());\n      bw = new BufferedWriter(fw);\n\n      bw.write(\"Spacely Sprockets\\nTaking Sprockets into the Future\\nSales Summary Report\\nSprocket Number Total Quantity Sold\\n\");\n      for (int i = 0; i < sum.length; i++) {\n        bw.write((i + 1) + \"\\t\" + sum[i] + \"\\n\");\n      }\n\n    } catch (IOException e) {\n      e.printStackTrace();\n    } finally {\n      try {\n        if (br != null)\n          br.close();\n        if (bw != null)\n          bw.close();\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}\n \n<<<explanation>>>: The issue lies in the way you are splitting the input line. The line.split(\" \") is splitting on a single space, but your input data seems to have multiple spaces between the numbers. This causes the NumberFormatException because \"3    50\" cannot be parsed as an integer.\n\nTo fix this, you can use the StringTokenizer class to split the line using multiple spaces as the delimiter. The updated code snippet above shows how you can use StringTokenizer to correctly split the input line, and parse the integers without the NumberFormatException."
            },
            "finish_reason": "stop"
        },
        {
            "index": 3,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: try {\n    br = new BufferedReader(new FileReader(\"C:\\\\sprocketorders.txt\"));\n    String line;\n    String element[] = new String[2];\n    int sum[] = new int[5];\n    File file = new File(\"C:\\\\sprocketordersreport.txt\");\n    while ((line = br.readLine()) != null) {\n        StringTokenizer st = new StringTokenizer(line);\n        element[0] = st.nextToken();\n        element[1] = st.nextToken();\n        switch (Integer.parseInt(element[0])) {\n            case 1:\n                sum[0] = sum[0] + Integer.parseInt(element[1]);\n                break;\n            case 2:\n                sum[1] = sum[1] + Integer.parseInt(element[1]);\n                break;\n            case 3:\n                sum[2] = sum[2] + Integer.parseInt(element[1]);\n                break;\n            case 4:\n                sum[3] = sum[3] + Integer.parseInt(element[1]);\n                break;\n            case 5:\n                sum[4] = sum[4] + Integer.parseInt(element[1]);\n                break;\n        }\n    }\n    if (!file.exists()) {\n        file.createNewFile();\n    }\n    FileWriter fw = new FileWriter(file.getAbsoluteFile());\n    bw = new BufferedWriter(fw);\n    bw.write(\"Spacely Sprockets\\nTaking Sprockets into the Future\\nSales Summary Report\\nSprocket Number Total Quantity Sold\\n\");\n    for (int i = 0; i < sum.length; i++)\n        bw.write((i + 1) + \"\\t\" + sum[i] + \"\\n\");\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    try {\n        if (br != null)\n            br.close();\n        if (bw != null)\n            bw.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n<<<explanation>>>: In this code, I have modified the implementation to use StringTokenizer to split the line into two elements, as you were doing previously. Then, I use Integer.parseInt() to convert the first element to an integer and assign it to the switch statement. This should solve the NumberFormatException error that you were encountering."
            },
            "finish_reason": "stop"
        },
        {
            "index": 4,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken()\n<<<code>>>: BufferedReader br = null;\nStringTokenizer st = null;\n\ntry {\n    br = new BufferedReader(new FileReader(\"C:\\\\sprocketorders.txt\"));\n    String line;\n    String element[] = new String[2];\n    int sum[] = new int[5];\n    File file = new File(\"C:\\\\sprocketordersreport.txt\");\n\n    while ((line = br.readLine()) != null) {\n        st = new StringTokenizer(line, \" \");\n\n        while (st.hasMoreTokens()) {\n            element = st.nextToken().split(\" \");\n            switch (Integer.parseInt(element[0])) {\n                case 1:\n                    sum[0] = sum[0] + Integer.parseInt(element[1]);\n                    break;\n                case 2:\n                    sum[1] = sum[1] + Integer.parseInt(element[1]);\n                    break;\n                case 3:\n                    sum[2] = sum[2] + Integer.parseInt(element[1]);\n                    break;\n                case 4:\n                    sum[3] = sum[3] + Integer.parseInt(element[1]);\n                    break;\n                case 5:\n                    sum[4] = sum[4] + Integer.parseInt(element[1]);\n                    break;\n            }\n        }\n    }\n\n    if (!file.exists()) {\n        file.createNewFile();\n    }\n    FileWriter fw = new FileWriter(file.getAbsoluteFile());\n    BufferedWriter bw = new BufferedWriter(fw);\n    bw.write(\"Spacely Sprockets\\nTaking Sprockets into the Future\\nSales Summary Report\\nSprocket Number Total Quantity Sold\\n\");\n    for (int i = 0; i < sum.length; i++) {\n        bw.write((i + 1) + \"\\t\" + sum[i] + \"\\n\");\n    }\n    bw.close();\n    br.close();\n} catch (IOException e) {\n    e.printStackTrace();\n} catch (NumberFormatException e) {\n    System.out.println(\"NumberFormatException: \" + e.getMessage());\n}\n          \n<<<explanation>>>: The issue with the code is that the String \"3    50\" cannot be converted to an integer using Integer.parseInt() because it contains multiple spaces between the numbers. To fix this, I have replaced the line `element = line.split(\" \")` with `st = new StringTokenizer(line, \" \")`. This uses the StringTokenizer API to tokenize the string based on spaces, and then I use st.nextToken() to get each individual token. This way, the String \"3    50\" will be correctly split into \"3\" and \"50\"."
            },
            "finish_reason": "stop"
        },
        {
            "index": 5,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public class ReportGenerator {\n  \n  public static void main(String[] args) {\n    BufferedReader br = null;\n    BufferedWriter bw = null;\n    try {\n      br = new BufferedReader(new FileReader(\"C:\\\\sprocketorders.txt\"));\n      String line;\n      String element[] = new String[2];\n      int sum[] = new int[5];\n      File file = new File(\"C:\\\\sprocketordersreport.txt\");\n      while ((line = br.readLine()) != null) {\n        StringTokenizer st = new StringTokenizer(line);\n        element[0] = st.nextToken();\n        element[1] = st.nextToken();\n        switch (Integer.parseInt(element[0])) {\n          case 1:\n            sum[0] += Integer.parseInt(element[1]);\n            break;\n          case 2:\n            sum[1] += Integer.parseInt(element[1]);\n            break;\n          case 3:\n            sum[2] += Integer.parseInt(element[1]);\n            break;\n          case 4:\n            sum[3] += Integer.parseInt(element[1]);\n            break;\n          case 5:\n            sum[4] += Integer.parseInt(element[1]);\n            break;\n        }\n      }\n      if (!file.exists()) {\n        file.createNewFile();\n      }\n      FileWriter fw = new FileWriter(file.getAbsoluteFile());\n      bw = new BufferedWriter(fw);\n      bw.write(\"Spacely Sprockets\\nTaking Sprockets into the Future\\nSales Summary Report\\nSprocket Number Total Quantity Sold\\n\");\n      for (int i = 0; i < sum.length; i++) {\n        bw.write((i + 1) + \"\\t\" + sum[i] + \"\\n\");\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    } finally {\n      try {\n        if (br != null)\n          br.close();\n        if (bw != null)\n          bw.close();\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}\n<<<explanation>>>: The issue is caused by line.split(\" \") splitting \"3    50\" into \"3\" and \"50\", while the code is expecting only two elements. To fix this issue, you can replace the line.split(\" \") with a StringTokenizer to properly split the line into two elements. The code above demonstrates how to use StringTokenizer in your code."
            },
            "finish_reason": "stop"
        },
        {
            "index": 6,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: Change line 28 in your code to this:\n```java\nelement = line.split(\"\\\\s+\");\n```\n<<<explanation>>>: The error is caused by the fact that there are multiple spaces between the integers in your input file. The `split()` method splits the string based on a regular expression, and in this case, we want to split on one or more whitespace characters. By using `\\\\s+` as the delimiter, we can split the string on one or more whitespace characters, including spaces and tabs. This will allow the program to correctly parse the input file and avoid the `NumberFormatException` error."
            },
            "finish_reason": "stop"
        },
        {
            "index": 7,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public class ReportGenerator {\n    public static void main(String[] args) {\n        BufferedReader br = null;\n        BufferedWriter bw = null;\n        try {\n            br = new BufferedReader(new FileReader(\"C:\\\\sprocketorders.txt\"));\n            String line;\n            String element[] = new String[2];\n            int sum[] = new int[5];\n            File file = new File(\"C:\\\\sprocketordersreport.txt\");\n            while ((line = br.readLine()) != null) {\n                StringTokenizer st = new StringTokenizer(line);\n                element[0] = st.nextToken();\n                element[1] = st.nextToken();\n                switch (Integer.parseInt(element[0])) {\n                    case 1:\n                        sum[0] = sum[0] + Integer.parseInt(element[1]);\n                        break;\n                    case 2:\n                        sum[1] = sum[1] + Integer.parseInt(element[1]);\n                        break;\n                    case 3:\n                        sum[2] = sum[2] + Integer.parseInt(element[1]);\n                        break;\n                    case 4:\n                        sum[3] = sum[3] + Integer.parseInt(element[1]);\n                        break;\n                    case 5:\n                        sum[4] = sum[4] + Integer.parseInt(element[1]);\n                        break;\n                }\n            }\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n            FileWriter fw = new FileWriter(file.getAbsoluteFile());\n            bw = new BufferedWriter(fw);\n            bw.write(\"Spacely Sprockets\\nTaking Sprockets into the Future\\nSales Summary Report\\nSprocket Number Total Quantity Sold\\n\");\n            for(int i = 0; i < sum.length; i++)\n                bw.write((i + 1) + \"\\t\" + sum[i] + \"\\n\");\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n        finally {\n            try {\n                if (br != null)\n                    br.close();\n                if (bw != null)\n                    bw.close();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n<<<explanation>>>: In the original code, the line.split(\" \") method was used to split the line into an array of strings. However, this method does not handle multiple spaces between the integers correctly. Instead, you can use StringTokenizer to split the line using spaces as the delimiter. Then, you can use StringTokenizer.nextToken() to get each token (number) from the line. By doing this, you can avoid the NumberFormatException error caused by the multiple spaces between the integers in the input file."
            },
            "finish_reason": "stop"
        },
        {
            "index": 8,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public class ReportGenerator {\n    public static void main(String[] args) {\n        BufferedReader br = null;\n        BufferedWriter bw = null;\n\n        try {\n            br = new BufferedReader(new FileReader(\"C:\\\\sprocketorders.txt\"));\n            String line;\n            String element[] = new String[2];\n            int sum[] = new int[5];\n            File file = new File(\"C:\\\\sprocketordersreport.txt\");\n\n            while ((line = br.readLine()) != null) {\n                StringTokenizer st = new StringTokenizer(line, \" \");\n                element[0] = st.nextToken();\n                element[1] = st.nextToken();\n                switch (Integer.parseInt(element[0])) {\n                    case 1:\n                        sum[0] = sum[0] + Integer.parseInt(element[1]);\n                        break;\n                    case 2:\n                        sum[1] = sum[1] + Integer.parseInt(element[1]);\n                        break;\n                    case 3:\n                        sum[2] = sum[2] + Integer.parseInt(element[1]);\n                        break;\n                    case 4:\n                        sum[3] = sum[3] + Integer.parseInt(element[1]);\n                        break;\n                    case 5:\n                        sum[4] = sum[4] + Integer.parseInt(element[1]);\n                        break;\n                }\n            }\n\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n\n            FileWriter fw = new FileWriter(file.getAbsoluteFile());\n            bw = new BufferedWriter(fw);\n\n            bw.write(\"Spacely Sprockets\\nTaking Sprockets into the Future\\nSales Summary Report\\nSprocket Number Total Quantity Sold\\n\");\n\n            for (int i = 0; i < sum.length; i++) {\n                bw.write((i + 1) + \"\\t\" + sum[i] + \"\\n\");\n            }\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (br != null)\n                    br.close();\n                if (bw != null)\n                    bw.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n<<<explanation>>>: The original code used line.split(\" \") to split the input line into elements. However, the issue seems to be that the input file has multiple spaces between the integers, causing the NumberFormatException. Instead of using line.split(\" \"), the new code uses the StringTokenizer.nextToken() method to split the line into two elements. This ensures that any number of spaces between the integers will not cause a problem."
            },
            "finish_reason": "stop"
        },
        {
            "index": 9,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: The error that you are receiving is a NumberFormatException in line 32 of your code. This is because you are trying to parse the string \"3    50\" as an integer, but it cannot be converted to an integer because it contains spaces. To solve this issue, you can modify your code to remove any spaces before parsing the integer value. Here is an example of how you can do this:\n\n...\nwhile ((line = br.readLine()) != null) {\n    element = line.split(\" \");\n    element[1] = element[1].replaceAll(\"\\\\s+\",\"\"); // Remove all spaces from the second element\n    switch(Integer.parseInt(element[0])) {\n        case 1:\n            // Handle case 1\n            break;\n        case 2:\n            // Handle case 2\n            break;\n        ...\n    }\n}\n...\n\nThis will remove any spaces from the second element before parsing it as an integer."
            },
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 1410,
        "completion_tokens": 4325,
        "total_tokens": 5735
    },
    "prompt": "Please answer my code questions using the given API following this format: <<<api>>>: $API\n<<<code>>>: $CODE\n<<<explanation>>>: $EXPLANATION.\nQuestion: Java StringTokenizer.nextToken() skips over empty fields:I am using a tab (/t) as delimiter and I know there are some empty fields in my data e.g.:\n\none->two->->three\nWhere -> equals the tab. As you can see an empty field is still correctly surrounded by tabs. Data is collected using a loop :\n\n while ((strLine = br.readLine()) != null) {\n    StringTokenizer st = new StringTokenizer(strLine, \"\t\");\n    String test = st.nextToken();\n    ...\n    }\nYet Java ignores this \"empty string\" and skips the field.\n\nIs there a way to circumvent this behaviour and force java to read in empty fields anyway?\nPlease using this api: StringTokenizer.nextToken.\nAnswer:<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public class TestStringTokenStrict {\n\n/**\n * Strict implementation of StringTokenizer\n * \n * @param str\n * @param delim\n * @param strict\n *            true = include NULL Token\n * @return\n */\nstatic StringTokenizer getStringTokenizerStrict(String str, String delim, boolean strict) {\n    StringTokenizer st = new StringTokenizer(str, delim, strict);\n    StringBuffer sb = new StringBuffer();\n\n    while (st.hasMoreTokens()) {\n        String s = st.nextToken();\n        if (s.equals(delim)) {\n            sb.append(\" \").append(delim);\n        } else {\n            sb.append(s).append(delim);\n            if (st.hasMoreTokens())\n                st.nextToken();\n        }\n    }\n    return (new StringTokenizer(sb.toString(), delim));\n}\n\nstatic void altStringTokenizer(StringTokenizer st) {\n    while (st.hasMoreTokens()) {\n        String type = st.nextToken();\n        String one = st.nextToken();\n        String two = st.nextToken();\n        String three = st.nextToken();\n        String four = st.nextToken();\n        String five = st.nextToken();\n\n        System.out.println(\n                \"[\" + type + \"] [\" + one + \"] [\" + two + \"] [\" + three + \"] [\" + four + \"] [\" + five + \"]\");\n    }\n}\n\npublic static void main(String[] args) {\n    String input = \"Record|One||Three||Five\";\n    altStringTokenizer(getStringTokenizerStrict(input, \"|\", true));\n}}\n<<<explanation>>>: The object your method decompressGZIP() needs is a byte[].\n\nSo the basic, technical answer to the question you have asked is:\nQuestion: Receiving NumberFormatException error when trying to run my program: :I asked this question earlier but was requested to add additional info and never got a response after that. Sorry ahead of time. I am not trying to spam the site or anything. I'm just looking for some assistance.I am receiving the error Exception in thread \"main\" java.lang.NumberFormatException: For input string: \"3 50\" in the code below. And I am having a hard time solving it. Could anyone possibly shed some light on what it could be from? From my understanding it usually means the error is in line 3 and line 50 correct? package report.generator; import java.io.BufferedReader; import java.io.FileReader; import java.io.File; import java.io.FileWriter; import java.io.BufferedWriter; import java.io.IOException; public class ReportGenerator { public static void main(String[] args) {    BufferedReader br = null;    BufferedWriter bw = null;    try    {        br = new BufferedReader(new FileReader(\"C:\\\\sprocketorders.txt\"));        String line;        String element[] = new String[2];        int   sum[] = new int[5];        File file = new File (\"C:\\\\sprocketordersreport.txt\");        while ((line = br.readLine()) != null)        {            element = line.split(\" \");            switch(Integer.parseInt(element[0]))            {                case 1:                    sum[0] = sum[0] + Integer.parseInt(element[1]);                    break;                case 2:                    sum[1] = sum[1] + Integer.parseInt(element[1]);                    break;                case 3:                    sum[2] = sum[2] + Integer.parseInt(element[1]);                    break;                case 4:                    sum[3] = sum[3] + Integer.parseInt(element[1]);                    break;                case 5:                    sum[4] = sum[4] + Integer.parseInt(element[1]);                    break;            }        }        if (!file.exists())        {            file.createNewFile();        }        FileWriter fw = new FileWriter(file.getAbsoluteFile());        bw = new BufferedWriter(fw);        bw.write(\"Spacely Sprockets\\nTaking Sprockets into the Future\\nSales Summary Report\\nSprocket Number Total Quantity Sold\\n\");        for(int i = 0; i < sum.length; i++)            bw.write((i + 1) + \"\\t\" + sum[i] + \"\\n\");    }    catch (IOException e)    {         e.printStackTrace();    }    finally    {       try        {            if (br != null)                br.close();            if (bw != null)                bw.close();        }        catch (IOException e)        {            e.printStackTrace();        }        }      }  }This program is to take an input from a text file and output the information in a report format.EDIT: Here is the input file info. After looking at it, it looks like this may be where the problem is coming from. But I'm not entirely sure.3 502 202 1005 151 905 854 3002 353 100It's not formatting it exactly as it is in the text file. There are more spaces between the integers on the left and those on the right.                        Spacely Sprockets                 Taking Sprockets into the Future                       Sales Summary Report    Sprocket Number                          Total Quantity Sold         1                                           90         2                                           155         3                                           50         4                                           300         5                                           100This is the output report that I am trying to get. Each number on the left is a sprocket number. The numbers on the right reflect the quantity sold of each sprocket.This is the full exception when trying to run:Exception in thread \"main\" java.lang.NumberFormatException: For input string: \"3    50\"at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)at java.lang.Integer.parseInt(Integer.java:492)at java.lang.Integer.parseInt(Integer.java:527)at report.generator.ReportGenerator.main(ReportGenerator.java:32)http://m.uploadedit.com/b034/1398740135243.txt\nPlease using this api: StringTokenizer.nextToken.\nAnswer:"
}