{
    "id": "chatcmpl-8HVq6u7wDG3N2tz7HlO8Ujdd6SDWt",
    "object": "chat.completion",
    "created": 1699184658,
    "model": "gpt-3.5-turbo-0613",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public class ShellTokenizer {\n    private String[][] cmdGrid;\n\n    public ShellTokenizer(String[][] cmdGrid) {\n        this.cmdGrid = cmdGrid;\n    }\n\n    public String[] tokenize(String input) {\n        String[] tokens = input.split(\" \");\n        String[] result = new String[tokens.length];\n\n        for (int i = 0; i < tokens.length; i++) {\n            result[i] = findMatch(tokens[i], i);\n        }\n\n        return result;\n    }\n\n    private String findMatch(String token, int depthmark) {\n        for (String[] row : cmdGrid) {\n            if (row[0].startsWith(token) && row.length > depthmark && row[depthmark].startsWith(token)) {\n                return row[depthmark];\n            }\n        }\n\n        return \"unknown\";\n    }\n\n    public static void main(String[] args) {\n        String[][] cmdGrid = {\n            {\"mysql\", \"dump\", \"grid\", \"se314\"},\n            {\"mysql\", \"connect\", \"grid\"},\n            {\"mysql\", \"dump\", \"grid\"},\n            {\"mysql\", \"connect\", \"rds\"}\n        };\n\n        ShellTokenizer tokenizer = new ShellTokenizer(cmdGrid);\n        String[] tokens = tokenizer.tokenize(\"my du gr ?\");\n        for (String token : tokens) {\n            System.out.println(token);\n        }\n    }\n}\n<<<explanation>>>: In this solution, we create a class called ShellTokenizer that takes the cmdGrid as a constructor parameter. The tokenize() method splits the input string into individual tokens and then uses the findMatch() method to search for a match in the cmdGrid. The findMatch() method iterates over each row in the cmdGrid and checks if the token matches the first element of the row and if the row has enough elements for the given depthmark. If a match is found, the corresponding element in the row is returned. If no match is found, \"unknown\" is returned. In the main method, we create an instance of ShellTokenizer and use it to tokenize the input string \"my du gr ?\". The resulting tokens are then printed to the console."
            },
            "finish_reason": "stop"
        },
        {
            "index": 1,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public class CommandTokenizer {\n    \n    public static String[][] makeGrid(String[] filenames) {\n        List<String[]> gridList = new ArrayList<>();\n        \n        for (String filename : filenames) {\n            if (!filename.endsWith(\".cmd\") && filename.contains(\"-\")) {\n                String[] tokens = filename.split(\"-\");\n                gridList.add(tokens);\n            }\n        }\n        \n        String[][] grid = new String[gridList.size()][];\n        gridList.toArray(grid);\n        \n        return grid;\n    }\n    \n    public static List<String> getMatchingCommands(String[][] grid, String[] cmdTokens) {\n        List<String> matchingCommands = new ArrayList<>();\n        \n        for (String[] row : grid) {\n            boolean match = true;\n            \n            for (int i = 0; i < cmdTokens.length; i++) {\n                if (!cmdTokens[i].isEmpty() && !row[i].startsWith(cmdTokens[i])) {\n                    match = false;\n                    break;\n                }\n            }\n            \n            if (match) {\n                matchingCommands.add(row[0]);\n            }\n        }\n        \n        return matchingCommands;\n    }\n    \n    public static void main(String[] args) {\n        String[] filenames = {\n            \"mysql-dump-grid-se314\",\n            \"mysql-connect-grid\",\n            \"mysql-dump-grid\",\n            \"mysql-connect-rds\"\n        };\n        \n        String[][] grid = makeGrid(filenames);\n        \n        String[] cmdTokens = {\"my\", \"du\", \"gr\"};\n        List<String> matchingCommands = getMatchingCommands(grid, cmdTokens);\n        \n        for (String command : matchingCommands) {\n            System.out.println(command);\n        }\n    }\n}\n<<<explanation>>>: The code provided includes two methods. The makeGrid() method takes an array of filenames, splits them by \"-\" delimiter, and creates a 2D array representing the grid. The getMatchingCommands() method takes the grid and an array of command tokens, and returns a list of matching commands based on the tokens provided. The main method demonstrates the usage of these methods by creating a sample grid and finding matching commands for the given command tokens."
            },
            "finish_reason": "stop"
        },
        {
            "index": 2,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public class CommandTokenizer {\n    private String[][] cmdGrid;\n    \n    public CommandTokenizer(String[][] cmdGrid) {\n        this.cmdGrid = cmdGrid;\n    }\n    \n    public String[][] tokenizeCommand(String command) {\n        StringTokenizer st = new StringTokenizer(command, \" \");\n        int numTokens = st.countTokens();\n        String[][] result = new String[cmdGrid.length][numTokens];\n        \n        for (int i = 0; i < cmdGrid.length; i++) {\n            for (int j = 0; j < numTokens; j++) {\n                String token = st.nextToken();\n                if (j >= cmdGrid[i].length || !cmdGrid[i][j].startsWith(token)) {\n                    result[i][j] = \"unknown\";\n                } else {\n                    result[i][j] = cmdGrid[i][j];\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n        String[][] cmdGrid = {\n            {\"mysql\", \"dump\", \"grid\", \"se314\"},\n            {\"mysql\", \"connect\", \"grid\"},\n            {\"mysql\", \"dump\", \"grid\"},\n            {\"mysql\", \"connect\", \"rds\"}\n        };\n        \n        CommandTokenizer tokenizer = new CommandTokenizer(cmdGrid);\n        String[][] result = tokenizer.tokenizeCommand(\"my du gr ?\");\n        \n        for (String[] row : result) {\n            for (String token : row) {\n                System.out.print(token + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n<<<explanation>>>: The CommandTokenizer class takes a 2-dimensional array cmdGrid as input, which represents the grid of potential commands. The tokenizeCommand() method takes a command string as input and tokenizes it using StringTokenizer. It then compares each token with the corresponding element in the cmdGrid to determine if it is a valid command. If a token does not match or if there are more tokens than elements in the cmdGrid, it sets the corresponding element in the result array to \"unknown\". Otherwise, it sets the element to the matched command. The main() method demonstrates how to use the CommandTokenizer class with a sample cmdGrid and command."
            },
            "finish_reason": "stop"
        },
        {
            "index": 3,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public static String[][] makeGrid(String[] strs, boolean bPrint) {\n    List<String[]> tmpGrid = new ArrayList<>();\n    int nMaxCols = 0;\n    int nRows = uniqueCount(strs);\n    int nGridRow = 0;\n\n    for (int nRow = 0; nRow < nRows; nRow++) {\n        String cFilename = strs[nRow];\n        if (!cFilename.endsWith(\".cmd\") && cFilename.indexOf(\"-\") > 0) {\n            String[] strTokens = tokenize(strs[nRow], \"-\");\n            int nCols = strTokens.length;\n            if (nCols > nMaxCols) nMaxCols = nCols;\n            tmpGrid.add(strTokens);\n            nGridRow++;\n            if (bPrint) {\n                for (int nCol = 0; nCol < nCols; nCol++) {\n                    System.out.print(\" \" + strTokens[nCol]);\n                }\n                System.out.println(\"\");\n            }\n        }\n    }\n\n    String[][] cmdGrid = new String[nGridRow][nMaxCols];\n    for (int i = 0; i < nGridRow; i++) {\n        cmdGrid[i] = tmpGrid.get(i);\n    }\n\n    return cmdGrid;\n}\n\npublic static String[] tokenize(String str, String delim) {\n    StringTokenizer st = new StringTokenizer(str, delim);\n    List<String> tokens = new ArrayList<>();\n    while (st.hasMoreTokens()) {\n        tokens.add(st.nextToken());\n    }\n    return tokens.toArray(new String[0]);\n}\n\npublic static int uniqueCount(String[] strs) {\n    Set<String> uniqueSet = new HashSet<>();\n    for (String str : strs) {\n        uniqueSet.add(str);\n    }\n    return uniqueSet.size();\n}\n\npublic static void main(String[] args) {\n    String[] input = {\"mysql dump grid se314\", \"mysql connect grid\", \"mysql dump grid\", \"mysql connect rds\"};\n    String[][] result = makeGrid(input, true);\n    System.out.println(Arrays.deepToString(result));\n}\n<<<explanation>>>: The makeGrid() method has been modified to use an ArrayList instead of a 2D array to store the tokenized strings. This allows for dynamic sizing of the grid. The tokenize() method has been added to split a string into tokens using a specified delimiter. The uniqueCount() method has been added to count the number of unique strings in an array. The main() method demonstrates the usage of the makeGrid() method with sample input."
            },
            "finish_reason": "stop"
        },
        {
            "index": 4,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public static String[][] makeGrid(String[] strs, boolean bPrint) {\n    String[][] tmpGrid;\n    int nMaxCols = 0;\n    int nRows = uniqueCount(strs);\n    int nGridRow = 0;\n    tmpGrid = new String[nRows][];\n\n    for (int nRow = 0; nRow < nRows; nRow++) {\n        String cFilename = strs[nRow];\n\n        if (!cFilename.endsWith(\".cmd\") && cFilename.indexOf(\"-\") > 0) {\n            String[] strTokens = cFilename.split(\"-\");\n            int nCols = strTokens.length;\n\n            if (nCols > nMaxCols) {\n                nMaxCols = nCols;\n            }\n\n            tmpGrid[nGridRow] = new String[nCols];\n\n            for (int nCol = 0; nCol < nCols; nCol++) {\n                tmpGrid[nGridRow][nCol] = strTokens[nCol];\n\n                if (bPrint) {\n                    System.out.print(\" \" + tmpGrid[nGridRow][nCol]);\n                }\n            }\n\n            nGridRow++;\n\n            if (bPrint) {\n                System.out.println(\"\");\n            }\n        }\n    }\n\n    String[][] cmdGrid = new String[nGridRow][nMaxCols];\n    System.arraycopy(tmpGrid, 0, cmdGrid, 0, nGridRow);\n\n    return cmdGrid;\n}\n\npublic static void main(String[] args) {\n    String[] input = {\"mysql-dump-grid-se314\", \"mysql-connect-grid\", \"mysql-dump-grid\", \"mysql-connect-rds\"};\n    String[][] grid = makeGrid(input, true);\n\n    // Your logic to match and retrieve distinct values goes here\n}\n<<<explanation>>>: The provided code takes an array of filenames and tokenizes them using the \"-\" delimiter. It then creates a 2-dimensional array with the tokenized values. The code also prints the grid if the \"bPrint\" flag is set to true. The main method shows an example usage of the makeGrid function. You can add your logic to match and retrieve distinct values from the grid."
            },
            "finish_reason": "stop"
        },
        {
            "index": 5,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public static String[][] filterGrid(String[][] grid, String[] cmdTokens) {\n    List<String[]> filteredRows = new ArrayList<>();\n\n    for (String[] row : grid) {\n        boolean match = true;\n        for (int i = 0; i < cmdTokens.length; i++) {\n            if (!row[i].startsWith(cmdTokens[i])) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            filteredRows.add(row);\n        }\n    }\n\n    String[][] filteredGrid = new String[filteredRows.size()][];\n    for (int i = 0; i < filteredRows.size(); i++) {\n        filteredGrid[i] = filteredRows.get(i);\n    }\n\n    return filteredGrid;\n}\n\npublic static void main(String[] args) {\n    String[][] grid = {\n            {\"mysql\", \"dump\", \"grid\", \"se314\"},\n            {\"mysql\", \"connect\", \"grid\"},\n            {\"mysql\", \"dump\", \"grid\"},\n            {\"mysql\", \"connect\", \"rds\"}\n    };\n\n    String[] cmdTokens = {\"my\", \"du\", \"gr\"};\n    String[][] filteredGrid = filterGrid(grid, cmdTokens);\n\n    for (String[] row : filteredGrid) {\n        System.out.println(Arrays.toString(row));\n    }\n}\n<<<explanation>>>: The filterGrid() method takes a 2-dimensional array (grid) and an array of command tokens (cmdTokens) as input. It iterates through each row in the grid and checks if the corresponding elements in the row match the command tokens. If all elements match, the row is added to a list of filtered rows. Finally, the filtered rows are converted back to a 2-dimensional array and returned.\n\nIn the main() method, a sample grid and command tokens are provided. The filterGrid() method is called with these inputs, and the filtered rows are printed to the console."
            },
            "finish_reason": "stop"
        },
        {
            "index": 6,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public static String[][] makeGrid(String[] strs, boolean bPrint) {\n  Set<String> distinctValues = new HashSet<>();\n  List<String[]> tmpGrid = new ArrayList<>();\n\n  for (String cFilename : strs) {\n    if (!cFilename.endsWith(\".cmd\") && cFilename.indexOf(\"-\") > 0) {\n      String[] strTokens = cFilename.split(\"-\");\n      tmpGrid.add(strTokens);\n      if (bPrint) {\n        for (String token : strTokens) {\n          System.out.print(\" \" + token);\n        }\n        System.out.println(\"\");\n      }\n    }\n  }\n\n  String[][] cmdGrid = new String[tmpGrid.size()][];\n  tmpGrid.toArray(cmdGrid);\n\n  return cmdGrid;\n}\n<<<explanation>>>: In the given code, the makeGrid() method creates a 2-dimensional array by tokenizing the filenames and filtering out certain conditions. To get distinct values based on specific conditions, you can use a Set to store the distinct values and then convert it back to a 2-dimensional array. The code provided above shows an updated version of the makeGrid() method that uses a Set to store distinct values and converts it back to a 2-dimensional array."
            },
            "finish_reason": "stop"
        },
        {
            "index": 7,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public static String[][] makeGrid(String[] strs, boolean bPrint) {\n    List<String[]> tmpGrid = new ArrayList<>();\n    int nMaxCols = 0;\n    int nRows = uniqueCount(strs);\n    int nGridRow = 0;\n\n    for (int nRow = 0; nRow < nRows; nRow++) {\n        String cFilename = strs[nRow];\n\n        if (!cFilename.endsWith(\".cmd\") && cFilename.indexOf(\"-\") > 0) {\n            String[] strTokens = cFilename.split(\"-\");\n            int nCols = strTokens.length;\n\n            if (nCols > nMaxCols) {\n                nMaxCols = nCols;\n            }\n\n            String[] row = new String[nCols];\n            System.arraycopy(strTokens, 0, row, 0, nCols);\n            tmpGrid.add(row);\n\n            if (bPrint) {\n                for (String token : row) {\n                    System.out.print(\" \" + token);\n                }\n                System.out.println(\"\");\n            }\n        }\n    }\n\n    String[][] cmdGrid = new String[nGridRow][nMaxCols];\n    cmdGrid = tmpGrid.toArray(cmdGrid);\n    return cmdGrid;\n}\n<<<explanation>>>: The makeGrid() method takes an array of filenames and tokenizes them using the \"-\" delimiter. It then stores the tokens in a 2D array. The method also has an option to print the tokens. The updated code uses the split() method instead of the StringTokenizer class, as it provides more flexibility and functionality. The tokens are stored in a List of String arrays, and then converted to a 2D array before being returned."
            },
            "finish_reason": "stop"
        },
        {
            "index": 8,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public static String[][] makeGrid(String[] strs, boolean bPrint) {\n    String[][] tmpGrid;\n    int nMaxCols = 0;\n    int nRows = uniqueCount(strs);\n    int nGridRow = 0;\n    tmpGrid = new String[nRows][];\n\n    for (int nRow = 0; nRow < nRows; nRow++) {\n        String cFilename = strs[nRow];\n\n        if (!cFilename.endsWith(\".cmd\") && cFilename.indexOf(\"-\") > 0) {\n            String[] strTokens = tokenize(strs[nRow], \"-\");\n            int nCols = strTokens.length;\n\n            if (nCols > nMaxCols)\n                nMaxCols = nCols;\n\n            tmpGrid[nGridRow] = new String[nCols];\n\n            for (int nCol = 0; nCol < nCols; nCol++) {\n                tmpGrid[nGridRow][nCol] = strTokens[nCol];\n\n                if (bPrint)\n                    System.out.print(\" \" + tmpGrid[nGridRow][nCol]);\n            }\n\n            nGridRow++;\n\n            if (bPrint)\n                System.out.println(\"\");\n        }\n    }\n\n    String[][] cmdGrid = new String[nGridRow][nMaxCols];\n    System.arraycopy(tmpGrid, 0, cmdGrid, 0, nGridRow);\n\n    return cmdGrid;\n}\n\npublic static int uniqueCount(String[] strs) {\n    Set<String> uniqueSet = new HashSet<>(Arrays.asList(strs));\n    return uniqueSet.size();\n}\n\npublic static String[] tokenize(String str, String delimiter) {\n    StringTokenizer st = new StringTokenizer(str, delimiter);\n    List<String> tokens = new ArrayList<>();\n\n    while (st.hasMoreTokens()) {\n        tokens.add(st.nextToken());\n    }\n\n    return tokens.toArray(new String[0]);\n}\n<<<explanation>>>: The makeGrid() method takes an array of filenames and tokenizes them using the \"-\" delimiter. It creates a 2-dimensional array to store the tokens. The uniqueCount() method is used to determine the number of rows in the grid. The tokenize() method is used to split a string into tokens using the specified delimiter. The resulting grid is returned."
            },
            "finish_reason": "stop"
        },
        {
            "index": 9,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public static String[][] makeGrid(String[] strs, boolean bPrint) {\n    List<String[]> gridList = new ArrayList<>();\n\n    for (String str : strs) {\n        if (!str.endsWith(\".cmd\") && str.contains(\"-\")) {\n            String[] tokens = str.split(\"-\");\n            gridList.add(tokens);\n        }\n    }\n\n    String[][] cmdGrid = new String[gridList.size()][];\n    for (int i = 0; i < gridList.size(); i++) {\n        cmdGrid[i] = gridList.get(i);\n    }\n\n    return cmdGrid;\n}\n\npublic static List<String> getDistinctValues(String[][] grid, int col, String prefix) {\n    List<String> distinctValues = new ArrayList<>();\n    for (String[] row : grid) {\n        if (row.length > col && row[col].startsWith(prefix)) {\n            String value = row[col];\n            if (!distinctValues.contains(value)) {\n                distinctValues.add(value);\n            }\n        }\n    }\n    return distinctValues;\n}\n\npublic static void main(String[] args) {\n    String[] input = {\"mysql dump grid se314\", \"mysql connect grid\", \"mysql dump grid\", \"mysql connect rds\"};\n    String[][] grid = makeGrid(input, true);\n\n    List<String> distinctValues = getDistinctValues(grid, 0, \"cmdToken1\");\n    System.out.println(distinctValues);\n}\n<<<explanation>>>: The makeGrid() method takes an array of filenames and creates a 2D grid by splitting each filename using the \"-\" delimiter. It only includes filenames that do not end with \".cmd\" and contain a \"-\". The resulting grid is returned as a 2D string array.\n\nThe getDistinctValues() method takes the grid, a column index, and a prefix as parameters. It iterates through each row in the grid and checks if the column value starts with the given prefix. If it does, the value is added to a list of distinct values. The list of distinct values is then returned.\n\nIn the main method, an example input array is created and passed to the makeGrid() method. The resulting grid is stored in the \"grid\" variable. The getDistinctValues() method is then called with the grid, column index 0, and the prefix \"cmdToken1\". The distinct values are printed to the console."
            },
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 1506,
        "completion_tokens": 4248,
        "total_tokens": 5754
    },
    "prompt": "Please answer my code questions using the given API following this format: <<<api>>>: $API\n<<<code>>>: $CODE\n<<<explanation>>>: $EXPLANATION.\nQuestion: Java StringTokenizer.nextToken() skips over empty fields:I am using a tab (/t) as delimiter and I know there are some empty fields in my data e.g.:\n\none->two->->three\nWhere -> equals the tab. As you can see an empty field is still correctly surrounded by tabs. Data is collected using a loop :\n\n while ((strLine = br.readLine()) != null) {\n    StringTokenizer st = new StringTokenizer(strLine, \"\t\");\n    String test = st.nextToken();\n    ...\n    }\nYet Java ignores this \"empty string\" and skips the field.\n\nIs there a way to circumvent this behaviour and force java to read in empty fields anyway?\nPlease using this api: StringTokenizer.nextToken.\nAnswer:<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public class TestStringTokenStrict {\n\n/**\n * Strict implementation of StringTokenizer\n * \n * @param str\n * @param delim\n * @param strict\n *            true = include NULL Token\n * @return\n */\nstatic StringTokenizer getStringTokenizerStrict(String str, String delim, boolean strict) {\n    StringTokenizer st = new StringTokenizer(str, delim, strict);\n    StringBuffer sb = new StringBuffer();\n\n    while (st.hasMoreTokens()) {\n        String s = st.nextToken();\n        if (s.equals(delim)) {\n            sb.append(\" \").append(delim);\n        } else {\n            sb.append(s).append(delim);\n            if (st.hasMoreTokens())\n                st.nextToken();\n        }\n    }\n    return (new StringTokenizer(sb.toString(), delim));\n}\n\nstatic void altStringTokenizer(StringTokenizer st) {\n    while (st.hasMoreTokens()) {\n        String type = st.nextToken();\n        String one = st.nextToken();\n        String two = st.nextToken();\n        String three = st.nextToken();\n        String four = st.nextToken();\n        String five = st.nextToken();\n\n        System.out.println(\n                \"[\" + type + \"] [\" + one + \"] [\" + two + \"] [\" + three + \"] [\" + four + \"] [\" + five + \"]\");\n    }\n}\n\npublic static void main(String[] args) {\n    String input = \"Record|One||Three||Five\";\n    altStringTokenizer(getStringTokenizerStrict(input, \"|\", true));\n}}\n<<<explanation>>>: The object your method decompressGZIP() needs is a byte[].\n\nSo the basic, technical answer to the question you have asked is:\nQuestion: Java Shell wildcard tokenizer: :My Java is extremely rusty and I'm stuck trying to make a user interface that simplifies the execution of shell scripts or batch files depending on whether it's Linus or Win32  respectively. The files have the following naming convention.  module-verb-object-etc [args-list]  mysql-connect-grid  mysql-connect-rds  mysql-dump-grid  mysql-dump-grid-se314ultimately I would like it to parse unambiguous terms so I can:tokenize the commands (e.g delimited by \"-\") & shorten them into simplified terms soemthing like foxpro's command window or cisco's IOS  (eg \"my co gr\" executes \"mysql-connect-grid\" in unix and *.cmd in win32)and also in the style of IOS allow the user to enter abbreviated commands so that they can type in  a question mark (?) and it will give them a hint as to the unique remaining (or next) command options (e.g. \"my?\" returns mysql  & \"my ?\" returns connect, or dump). Othr return values would be \"ambiguous\" or \"unknown\" for commands that are not unique or could not be matched. It may seem trivial but there are many hundreds of commands in each folder and my users don't want to think... I wrote a function to pull the list of files from a directory & retun an array of fileanmes. Then I convert that into a 2 dimensional array using the method below which returns a dynamicly sized grid of potential commands.    /**********************************************************************************     *  MAKE GRID: Parses array of filenames and tokenizes AWS cmds.     * @param strs  Array of filenames     **********************************************************************************/     public static String [][] makeGrid(String strs[], boolean bPrint) {       String tmpGrid[][];       int nMaxCols = 0;       int nRows = uniqueCount(strs);       int nGridRow = 0;        tmpGrid = new String [nRows][];        for (int nRow=0; nRow<nRows; nRow++) {  String cFilename = strs[nRow];                if (!cFilename.endsWith(\".cmd\") // just list unix files (filter for batch files)    && cFilename.indexOf(\"-\") > 0 ) // make sure there's a dash in the filename    {           String strTokens[] = tokenize(strs[nRow], \"-\"); // the dash is our token deliminator           int nCols = strTokens.length;            if (nCols>nMaxCols) nMaxCols=nCols;           tmpGrid[nGridRow] = new String [nCols];           for (int nCol=0; nCol<nCols; nCol++) {                tmpGrid[nGridRow][nCol] = strTokens[nCol];               if (bPrint) System.out.print(\" \"+tmpGrid[nGridRow][nCol]);             }            nGridRow++;            if (bPrint) System.out.println(\"\");     } //end-if         }       String[][] cmdGrid = new String[nGridRow][nMaxCols];       System.arraycopy(tmpGrid, 0, cmdGrid, 0, nGridRow); // removes null rows  (&NPEs!)       return cmdGrid;      }This returns a 2-d array (below), so grid[Row-N][Col-0] is a match. I'd like to pull only distinct values where row[0] is a wildcard match for cmdToken[0] && row[1] is \"like\" cmdToken[1] so that my users can piece together a command until \"my du gr ?\" returns \"ENTER, [se314]\" - if that makes sense...String[][] makeGrid:    mysql dump grid se314    mysql connect grid    mysql dump grid    mysql connect rdsMy Challenge: I cant seem to get my head around my matcher function in java. If it was SQL it would be something like: \"SELECT DISTINCT col2 FROM cmd_Grid   WHERE col1 LIKE 'cmdToken1%' \" or even better: recursively setting a int depthmark for each consecutive column`SELECT DISTINCT col+str(depthmark+1) FROM cmd_Grid     WHERE col+str(depthmark) LIKE 'cmdMatchedTokens%' \" until you have an exact match. I found a package called joSQL that I tried out of desperation but I cant seem to get it to work in Java6. Anyway: I was also hoping for a pure java solution so that everything could be contained in a single class... Maybe using scanner or something to parse my multidimentional array for unique values... I know I'm probably making it way more complex than it needs to be. a gentle nudge in the right direction would be appreciated.TIA\nPlease using this api: StringTokenizer.nextToken.\nAnswer:"
}