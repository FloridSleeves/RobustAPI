{
    "id": "chatcmpl-8HW2idU3lm7mV2GDxbdNwpO4nBVWd",
    "object": "chat.completion",
    "created": 1699185440,
    "model": "gpt-3.5-turbo-0613",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: try {\n    File GFile = new File(\"C:\\\\Users\\\\Gordy\\\\Dropbox\\\\IT\\\\Hotel Reservation\\\\Hotel\\\\src\\\\Reservation\\\\Guests.txt\");\n    PrintWriter pw = new PrintWriter(new FileWriter(GFile, true));\n\n    if (!GFile.exists()) {\n        GFile.createNewFile();\n    }\n\n    String delim = \"#\";\n    String Firstname = NameF.getText();\n    String Lastname = NameL.getText();\n    String Country = Countr.getText();\n    String IDtype = IDTy.getText();\n    String PassportNo = PassNo.getText();\n    String IDNo = IDNumber.getText();\n    String Addr1 = Add1.getText();\n    String Addr2 = Add2.getText();\n    int AreaCode = Integer.parseInt(Area.getText());\n    String TelNo = Tel.getText();\n    String CellNo = Cell.getText();\n    String Email = Em.getText();\n\n    String data = Firstname + delim + Lastname + delim + Country + delim + IDtype + delim + PassportNo + delim + IDNo + delim + Addr1 + delim + Addr2 + delim + AreaCode + delim + TelNo + delim + CellNo + delim + Email;\n\n    pw.println(data);\n    pw.close();\n    CheckIn.hide();\n    Home.this.setVisible(true);\n} catch (Exception e) {\n    System.out.print(\"This did not work heres the error: \" + e);\n}\n<<<explanation>>>: The error you are getting is because you are not correctly using the StringTokenizer. You are not passing the correct delimiter to the StringTokenizer constructor. Instead of using StringTokenizer, you can directly concatenate the values with the delimiter and write it to the file."
            },
            "finish_reason": "stop"
        },
        {
            "index": 1,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: String delim = \"#\";\nStringTokenizer stk = new StringTokenizer(delim);\nFirstname += stk.nextToken();\nSystem.out.print(\"FName = \" + Firstname);\nLastname += stk.nextToken();\nSystem.out.print(\"LastName= \" + Lastname);\nCountry += stk.nextToken();\nSystem.out.print(\"Country= \" + Country);\nIDtype += stk.nextToken();\nIDNo += stk.nextToken();\nAddr1 += stk.nextToken();\nAddr2 += stk.nextToken();\nAreaCode += Integer.parseInt(stk.nextToken());\nTelNo += stk.nextToken();\nCellNo += stk.nextToken();\nEmail += stk.nextToken();\nGArr[count] = new Guests(Firstname, Lastname, Country, IDtype, IDNo, Addr1, Addr2, AreaCode, TelNo, CellNo, Email);\nPrintWriter pw=new PrintWriter(new FileWriter (GFile,true));\npw.println(GArr[count]);\ncount++;\npw.close();\nCheckIn.hide();\nHome.this.setVisible(true);\n<<<explanation>>>: The code you provided is trying to use StringTokenizer to parse a string with the delimiter \"#\". However, you didn't pass the string to be parsed as the first argument to the StringTokenizer constructor. Instead, you passed the delimiter string as the first argument. To fix this issue, you need to pass the string to be parsed as the first argument and the delimiter string as the second argument to the StringTokenizer constructor. Here's the corrected code:\n\n```java\nString input = NameF.getText() + \"#\" + NameL.getText() + \"#\" + Countr.getText() + \"#\" + IDTy.getText() + \"#\" + PassNo.getText() + \"#\" + IDNumber.getText() + \"#\" + Add1.getText() + \"#\" + Add2.getText() + \"#\" + Area.getText() + \"#\" + Tel.getText() + \"#\" + Cell.getText() + \"#\" + Em.getText();\nStringTokenizer stk = new StringTokenizer(input, \"#\");\nFirstname = stk.nextToken();\nSystem.out.print(\"FName = \" + Firstname);\nLastname = stk.nextToken();\nSystem.out.print(\"LastName= \" + Lastname);\nCountry = stk.nextToken();\nSystem.out.print(\"Country= \" + Country);\nIDtype = stk.nextToken();\nIDNo = stk.nextToken();\nAddr1 = stk.nextToken();\nAddr2 = stk.nextToken();\nAreaCode = Integer.parseInt(stk.nextToken());\nTelNo = stk.nextToken();\nCellNo = stk.nextToken();\nEmail = stk.nextToken();\nGArr[count] = new Guests(Firstname, Lastname, Country, IDtype, IDNo, Addr1, Addr2, AreaCode, TelNo, CellNo, Email);\nPrintWriter pw = new PrintWriter(new FileWriter(GFile, true));\npw.println(GArr[count]);\ncount++;\npw.close();\nCheckIn.hide();\nHome.this.setVisible(true);\n```\n\nThis code will properly parse the input string using the delimiter \"#\" and assign the parsed values to the respective variables. It will then create a new instance of the Guests class with the parsed values and write it to the file."
            },
            "finish_reason": "stop"
        },
        {
            "index": 2,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: String delim = \"#\";\n           String Firstname = NameF.getText();\n           StringTokenizer stk = new StringTokenizer(delim);\n           Firstname += stk.nextToken();\n           System.out.print(\"FName = \" + Firstname);\n           Lastname += stk.nextToken();\n           System.out.print(\"LastName= \" + Lastname);\n           Country += stk.nextToken();\n           System.out.print(\"Country= \" + Country);\n           IDtype += stk.nextToken();\n           IDNo += stk.nextToken();\n           Addr1 += stk.nextToken();\n           Addr2 += stk.nextToken();\n           AreaCode += Integer.parseInt(stk.nextToken());\n           TelNo += stk.nextToken();\n           CellNo += stk.nextToken();\n           Email += stk.nextToken();\n           GArr[count] = new Guests(Firstname, Lastname, Country, IDtype, IDNo, Addr1, Addr2, AreaCode, TelNo, CellNo, Email);\n           PrintWriter pw=new PrintWriter(new FileWriter (GFile,true));\n           pw.println(GArr[count]);\n           count++;\n           pw.close();\n           CheckIn.hide();\n           Home.this.setVisible(true);\n           \n<<<explanation>>>: The error you are getting is a \"NoSuchElementException\" which means that the StringTokenizer is trying to retrieve a token that does not exist. This is because you did not pass the input string to the StringTokenizer constructor. To fix this, you need to pass the input string to the constructor like this: StringTokenizer stk = new StringTokenizer(input, delim);. Additionally, you need to make sure that the input string contains the delimiter character."
            },
            "finish_reason": "stop"
        },
        {
            "index": 3,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public class TestStringToken {\n\n    public static void main(String[] args) {\n        String input = \"Record|One||Three||Five\";\n        StringTokenizer st = new StringTokenizer(input, \"|\", true);\n        \n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            System.out.println(\"Token: \" + token);\n        }\n    }\n}\n<<<explanation>>>: In this code, we create a StringTokenizer object with the input string and the delimiter \"|\". We also set the third parameter to true, which means that the delimiter should be treated as a token. \n\nThen, we use a while loop to iterate through all the tokens in the input string. We use the hasMoreTokens() method to check if there are more tokens, and the nextToken() method to get the next token. \n\nIn the output, you will see that the empty fields are also included as tokens."
            },
            "finish_reason": "stop"
        },
        {
            "index": 4,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: String delim = \"#\";\n           String Firstname = NameF.getText();\n           StringTokenizer stk = new StringTokenizer(delim);\n           Firstname += stk.nextToken();\n           Lastname += stk.nextToken();\n           Country += stk.nextToken();\n           IDtype += stk.nextToken();\n           IDNo += stk.nextToken();\n           Addr1 += stk.nextToken();\n           Addr2 += stk.nextToken();\n           AreaCode += Integer.parseInt(stk.nextToken());\n           TelNo += stk.nextToken();\n           CellNo += stk.nextToken();\n           Email += stk.nextToken();\n          \n<<<explanation>>>: The error message \"java.util.NoSuchElementException\" is thrown because you are not providing the delimiter when creating the StringTokenizer object. In your code, you are passing only the string \"delim\" to the constructor of StringTokenizer, which is incorrect. \n\nTo fix this issue, you need to pass the actual string that you want to tokenize as the first argument to the constructor of StringTokenizer. In your case, it seems like you want to tokenize the string stored in the variable \"delim\", so you should change the code to:\n\nStringTokenizer stk = new StringTokenizer(Firstname, delim);\n\nThis will create a StringTokenizer object that will tokenize the string stored in the variable \"Firstname\" using the delimiter stored in the variable \"delim\"."
            },
            "finish_reason": "stop"
        },
        {
            "index": 5,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: String delim = \"#\";\n           StringTokenizer stk = new StringTokenizer(delim);\n           Firstname += stk.nextToken();\n           Lastname += stk.nextToken();\n           Country += stk.nextToken();\n           IDtype += stk.nextToken();\n           IDNo += stk.nextToken();\n           Addr1 += stk.nextToken();\n           Addr2 += stk.nextToken();\n           AreaCode += Integer.parseInt(stk.nextToken());\n           TelNo += stk.nextToken();\n           CellNo += stk.nextToken();\n           Email += stk.nextToken();\n           \n           GArr[count] = new Guests(Firstname, Lastname, Country, IDtype, IDNo, Addr1, Addr2, AreaCode, TelNo, CellNo, Email);\n           \n           PrintWriter pw = new PrintWriter(new FileWriter(GFile, true));\n           pw.println(GArr[count]);\n           count++;\n           pw.close();\n           \n           CheckIn.hide();\n           Home.this.setVisible(true);\n           \n<<<explanation>>>: The error you are getting is because you are not providing the delimiter to the StringTokenizer constructor. In your code, you are passing \"delim\" as the argument to the constructor, which is an empty string. This is why you are getting a NoSuchElementException when calling nextToken().\n\nTo fix this, you need to pass the actual delimiter string to the constructor. In your case, it seems like the delimiter is \"#\". So you can change your code to:\n\nString delim = \"#\";\nStringTokenizer stk = new StringTokenizer(delim);\nFirstname += stk.nextToken();\nLastname += stk.nextToken();\nCountry += stk.nextToken();\nIDtype += stk.nextToken();\nIDNo += stk.nextToken();\nAddr1 += stk.nextToken();\nAddr2 += stk.nextToken();\nAreaCode += Integer.parseInt(stk.nextToken());\nTelNo += stk.nextToken();\nCellNo += stk.nextToken();\nEmail += stk.nextToken();\n\nGArr[count] = new Guests(Firstname, Lastname, Country, IDtype, IDNo, Addr1, Addr2, AreaCode, TelNo, CellNo, Email);\n\nPrintWriter pw = new PrintWriter(new FileWriter(GFile, true));\npw.println(GArr[count]);\ncount++;\npw.close();\n\nCheckIn.hide();\nHome.this.setVisible(true);\n\nThis code will correctly tokenize the input string using \"#\" as the delimiter and assign the tokens to the corresponding variables. It will then create a new Guest object and add it to the GArr array. Finally, it will write the Guest object to the file and close the PrintWriter."
            },
            "finish_reason": "stop"
        },
        {
            "index": 6,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: String delim = \"#\";\n           String Firstname = NameF.getText();\n           StringTokenizer stk = new StringTokenizer(delim);\n           Firstname += stk.nextToken();\n           System.out.print(\"FName = \" + Firstname);\n           Lastname += stk.nextToken();\n           System.out.print(\"LastName= \" + Lastname);\n           Country += stk.nextToken();\n           System.out.print(\"Country= \" + Country);\n           IDtype += stk.nextToken();\n           IDNo += stk.nextToken();\n           Addr1 += stk.nextToken();\n           Addr2 += stk.nextToken();\n           AreaCode += Integer.parseInt(stk.nextToken());\n           TelNo += stk.nextToken();\n           CellNo += stk.nextToken();\n           Email += stk.nextToken();\n           GArr[count] = new Guests(Firstname, Lastname, Country, IDtype, IDNo, Addr1, Addr2, AreaCode, TelNo, CellNo, Email);\n           PrintWriter pw=new PrintWriter(new FileWriter (GFile,true));\n           pw.println(GArr[count]);\n           count++;\n           pw.close();\n           CheckIn.hide();\n           Home.this.setVisible(true);\n<<<explanation>>>: The error \"java.util.NoSuchElementException\" is thrown because you are not providing any tokens to the StringTokenizer object. You need to pass the string that you want to tokenize as the first argument to the constructor. In your code, you are passing the delimiter string (\"#\") instead of the input string.\n\nTo fix this, you should pass the input string (e.g., Firstname) to the StringTokenizer constructor instead of the delimiter string:\n\nStringTokenizer stk = new StringTokenizer(Firstname, delim);\n\nAlso, make sure that you have enough tokens in the input string to match the number of calls to nextToken(). Otherwise, you will get a NoSuchElementException."
            },
            "finish_reason": "stop"
        },
        {
            "index": 7,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: String delim = \"#\";\n           StringTokenizer stk = new StringTokenizer(delim);\n           Firstname += stk.nextToken();\n           Lastname += stk.nextToken();\n           Country += stk.nextToken();\n           IDtype += stk.nextToken();\n           IDNo += stk.nextToken();\n           Addr1 += stk.nextToken();\n           Addr2 += stk.nextToken();\n           AreaCode += Integer.parseInt(stk.nextToken());\n           TelNo += stk.nextToken();\n           CellNo += stk.nextToken();\n           Email += stk.nextToken();\n           \n           GArr[count] = new Guests(Firstname, Lastname, Country, IDtype, IDNo, Addr1, Addr2, AreaCode, TelNo, CellNo, Email);\n           \n           PrintWriter pw = new PrintWriter(new FileWriter(GFile, true));\n           pw.println(GArr[count]);\n           count++;\n           pw.close();\n           \n           CheckIn.hide();\n           Home.this.setVisible(true);\n           \n<<<explanation>>>: The error you are getting is a NoSuchElementException, which means that there are no more tokens to be found in the StringTokenizer. This is because you are not providing any input string to the StringTokenizer. In your code, you have declared a delimiter string, but you are not passing any input string to the StringTokenizer constructor.\n\nTo fix this, you need to pass the input string that you want to tokenize to the StringTokenizer constructor. In your case, it seems like you want to tokenize the input string stored in the TextFields. So, you should pass the input string from the TextFields to the StringTokenizer constructor.\n\nFor example, if you want to tokenize the input string in the NameF TextField, you can modify your code like this:\n\nString Firstname = NameF.getText();\nStringTokenizer stk = new StringTokenizer(Firstname, delim);\nFirstname += stk.nextToken();\n\nYou can do the same for the other fields as well.\n\nAlso, note that StringTokenizer is a legacy class and it is recommended to use the split() method of the String class instead. The split() method allows you to split a string into an array of substrings based on a specified delimiter. Here's how you can use the split() method to achieve the same result:\n\nString[] tokens = Firstname.split(delim);\nFirstname += tokens[0];\n\nYou can do the same for the other fields as well."
            },
            "finish_reason": "stop"
        },
        {
            "index": 8,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: String delim = \"#\";\n           String Firstname = NameF.getText();\n           StringTokenizer stk = new StringTokenizer(delim);\n           Firstname += stk.nextToken();\n           System.out.print(\"FName = \" + Firstname);\n           Lastname += stk.nextToken();\n           System.out.print(\"LastName= \" + Lastname);\n           Country += stk.nextToken();\n           System.out.print(\"Country= \" + Country);\n           IDtype += stk.nextToken();\n           IDNo += stk.nextToken();\n           Addr1 += stk.nextToken();\n           Addr2 += stk.nextToken();\n           AreaCode += Integer.parseInt(stk.nextToken());\n           TelNo += stk.nextToken();\n           CellNo += stk.nextToken();\n           Email += stk.nextToken();\n           GArr[count] = new Guests(Firstname, Lastname, Country, IDtype, IDNo, Addr1, Addr2, AreaCode, TelNo, CellNo, Email);\n           PrintWriter pw=new PrintWriter(new FileWriter (GFile,true));\n           pw.println(GArr[count]);\n           count++;\n           pw.close();\n           CheckIn.hide();\n           Home.this.setVisible(true);\n           \n<<<explanation>>>: The error you are getting is because you are not passing the correct delimiter to the StringTokenizer constructor. In your code, you are passing \"delim\" as the delimiter, which is a string containing only \"#\". This means that the StringTokenizer will treat \"#\" as the delimiter and try to tokenize the input string based on this delimiter. However, in your code, you are not providing any input string to the StringTokenizer constructor, so it is trying to tokenize an empty string, which results in a NoSuchElementException.\n\nTo fix this issue, you need to pass the input string that you want to tokenize as the first argument to the StringTokenizer constructor. In your case, it seems like you want to tokenize the values of the text fields. So, you should pass the values of the text fields as the input string to the StringTokenizer constructor. For example, you can modify your code like this:\n\nString delim = \"#\";\nString Firstname = NameF.getText();\nStringTokenizer stk = new StringTokenizer(Firstname, delim);\nFirstname = stk.nextToken();\nSystem.out.print(\"FName = \" + Firstname);\nLastname = stk.nextToken();\nSystem.out.print(\"LastName= \" + Lastname);\nCountry = stk.nextToken();\nSystem.out.print(\"Country= \" + Country);\nIDtype = stk.nextToken();\nIDNo = stk.nextToken();\nAddr1 = stk.nextToken();\nAddr2 = stk.nextToken();\nAreaCode = Integer.parseInt(stk.nextToken());\nTelNo = stk.nextToken();\nCellNo = stk.nextToken();\nEmail = stk.nextToken();\nGArr[count] = new Guests(Firstname, Lastname, Country, IDtype, IDNo, Addr1, Addr2, AreaCode, TelNo, CellNo, Email);\nPrintWriter pw = new PrintWriter(new FileWriter(GFile, true));\npw.println(GArr[count]);\ncount++;\npw.close();\nCheckIn.hide();\nHome.this.setVisible(true);\n\nThis code will tokenize the value of the \"Firstname\" text field using \"#\" as the delimiter, and assign the tokenized values to the respective variables."
            },
            "finish_reason": "stop"
        },
        {
            "index": 9,
            "message": {
                "role": "assistant",
                "content": "<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: String delim = \"#\";\nStringTokenizer stk = new StringTokenizer(delim);\nFirstname += stk.nextToken();\nSystem.out.print(\"FName = \" + Firstname);\nLastname += stk.nextToken();\nSystem.out.print(\"LastName= \" + Lastname);\nCountry += stk.nextToken();\nSystem.out.print(\"Country= \" + Country);\nIDtype += stk.nextToken();\nIDNo += stk.nextToken();\nAddr1 += stk.nextToken();\nAddr2 += stk.nextToken();\nAreaCode += Integer.parseInt(stk.nextToken());\nTelNo += stk.nextToken();\nCellNo += stk.nextToken();\nEmail += stk.nextToken();\nGArr[count] = new Guests(Firstname, Lastname, Country, IDtype, IDNo, Addr1, Addr2, AreaCode, TelNo, CellNo, Email);\nPrintWriter pw=new PrintWriter(new FileWriter (GFile,true));\npw.println(GArr[count]);\ncount++;\npw.close();\nCheckIn.hide();\nHome.this.setVisible(true);\n<<<explanation>>>: The error \"java.util.NoSuchElementException\" occurs because you are not providing any input to the StringTokenizer constructor. You need to pass the string that you want to tokenize as the first argument. In your case, you should pass the string that contains the values from the text fields. Additionally, you need to pass the delimiter string as the second argument. In your case, the delimiter is \"#\". After that, you can use the nextToken() method to get each token and assign it to the corresponding variable."
            },
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 1804,
        "completion_tokens": 3946,
        "total_tokens": 5750
    },
    "prompt": "Please answer my code questions using the given API following this format: <<<api>>>: $API\n<<<code>>>: $CODE\n<<<explanation>>>: $EXPLANATION.\nQuestion: Java StringTokenizer.nextToken() skips over empty fields:I am using a tab (/t) as delimiter and I know there are some empty fields in my data e.g.:\n\none->two->->three\nWhere -> equals the tab. As you can see an empty field is still correctly surrounded by tabs. Data is collected using a loop :\n\n while ((strLine = br.readLine()) != null) {\n    StringTokenizer st = new StringTokenizer(strLine, \"\t\");\n    String test = st.nextToken();\n    ...\n    }\nYet Java ignores this \"empty string\" and skips the field.\n\nIs there a way to circumvent this behaviour and force java to read in empty fields anyway?\nPlease using this api: StringTokenizer.nextToken.\nAnswer:<<<api>>>: StringTokenizer.nextToken\n<<<code>>>: public class TestStringTokenStrict {\n\n/**\n * Strict implementation of StringTokenizer\n * \n * @param str\n * @param delim\n * @param strict\n *            true = include NULL Token\n * @return\n */\nstatic StringTokenizer getStringTokenizerStrict(String str, String delim, boolean strict) {\n    StringTokenizer st = new StringTokenizer(str, delim, strict);\n    StringBuffer sb = new StringBuffer();\n\n    while (st.hasMoreTokens()) {\n        String s = st.nextToken();\n        if (s.equals(delim)) {\n            sb.append(\" \").append(delim);\n        } else {\n            sb.append(s).append(delim);\n            if (st.hasMoreTokens())\n                st.nextToken();\n        }\n    }\n    return (new StringTokenizer(sb.toString(), delim));\n}\n\nstatic void altStringTokenizer(StringTokenizer st) {\n    while (st.hasMoreTokens()) {\n        String type = st.nextToken();\n        String one = st.nextToken();\n        String two = st.nextToken();\n        String three = st.nextToken();\n        String four = st.nextToken();\n        String five = st.nextToken();\n\n        System.out.println(\n                \"[\" + type + \"] [\" + one + \"] [\" + two + \"] [\" + three + \"] [\" + four + \"] [\" + five + \"]\");\n    }\n}\n\npublic static void main(String[] args) {\n    String input = \"Record|One||Three||Five\";\n    altStringTokenizer(getStringTokenizerStrict(input, \"|\", true));\n}}\n<<<explanation>>>: The object your method decompressGZIP() needs is a byte[].\n\nSo the basic, technical answer to the question you have asked is:\nQuestion: Cant understand why this doesn't print to the text file: :Im coding a hotel reservation program and im using a GUI to input the Guests info into TextFields. I have an array where these input values should go straight to (maybe thats my problem, but donno how to fix it). After this I want the values in the Array to print to the text file I had created. Heres my code:Guests[] GArr = new Guests[1000];   public static DateFormat dateFormat = new SimpleDateFormat(\"dd/MM/yyyy HH:mm\");   public int cnt = 1;   int count = 0;   String Firstname ;   String Lastname;   String Country ;   String IDtype;   String PassportNo ;   String IDNo ;   String Addr1;   String Addr2 ;   int AreaCode ;   String TelNo ;   String CellNo ;   String Email ;First I have declared these variables as global (these variables are already in my object class Guests) i put them again in my JFrame class called Home. After that I have made these variables take the value of the TextFields that have text input into them. This is within a method that checks to see if the fields are blank:public Collection<String> getNonBlankFields()  {    this.Firstname = NameF.getText();    this.Lastname = NameL.getText();    this.Country = Countr.getText();   this.IDtype = IDTy.getText();    this.PassportNo = PassNo.getText();    this.IDNo = IDNumber.getText();    this.Addr1 = Add1.getText();    this.Addr2 = Add2.getText();    int AreaCode = Integer.parseInt(Area.getText());    this.TelNo = Tel.getText();    this.CellNo = Cell.getText();    this.Email = Em.getText();    this.nonBlankFields = new ArrayList<String>();    this.nonBlankFields.add(this.Firstname);    this.nonBlankFields.add(this.Lastname);    this.nonBlankFields.add(this.Country);    this.nonBlankFields.add(this.IDtype);    this.nonBlankFields.add(this.PassportNo);    this.nonBlankFields.add(this.IDNo);    this.nonBlankFields.add(this.Addr1);    this.nonBlankFields.add(this.Addr2);    this.nonBlankFields.add(this.TelNo);    this.nonBlankFields.add(this.CellNo);    this.nonBlankFields.add(this.Email);    System.out.println(this.nonBlankFields);    return this.nonBlankFields;}Last thing is the printing to the file (this is my major problem) ive tried so many things to fix this but it surpasses this code and goes straight to the catch:     File GFile = new File(\"C:\\\\Users\\\\Gordy\\\\Dropbox\\\\IT\\\\Hotel Reservation\\\\Hotel\\\\src\\\\Reservation\\\\Guests.txt\");try {            if (!GFile.exists()) {                GFile.createNewFile();            }                 String delim = \"#\";               String Firstname = NameF.getText();                    StringTokenizer stk = new StringTokenizer(delim);                    Firstname += stk.nextToken();                    System.out.print(\"FName = \" + Firstname);                    Lastname += stk.nextToken();                    System.out.print(\"LastName= \" + Lastname);                    Country += stk.nextToken();                    System.out.print(\"Country= \" + Country);                    IDtype += stk.nextToken();                    IDNo += stk.nextToken();                    Addr1 += stk.nextToken();                    Addr2 += stk.nextToken();                    AreaCode += Integer.parseInt(stk.nextToken());                    TelNo += stk.nextToken();                    CellNo += stk.nextToken();                    Email += stk.nextToken();                    GArr[count] = new Guests(Firstname, Lastname, Country, IDtype,  IDNo,Addr1,Addr2, AreaCode, TelNo, CellNo, Email);                    PrintWriter pw=new PrintWriter(new FileWriter (GFile,true));                    pw.println(GArr[count]);                    count++;                    pw.close();                    CheckIn.hide();                    Home.this.setVisible(true);            }         catch (Exception e) {            System.out.print(\"This did not work heres the error: \" + e);        }would also love to use anything but StringTokenizer to print with # in between the data on 1 line.     this is the whole error:    java.util.NoSuchElementExceptionat java.util.StringTokenizer.nextToken(StringTokenizer.java:332)at Reservation.Home.jButton8ActionPerformed(Home.java:1657)at Reservation.Home.access$100(Home.java:29)at Reservation.Home$2.actionPerformed(Home.java:269)at javax.swing.AbstractButton.fireActionPerformed(AbstractButton.java:1995)at javax.swing.AbstractButton$Handler.actionPerformed(AbstractButton.java:2318)at javax.swing.DefaultButtonModel.fireActionPerformed(DefaultButtonModel.java:387)at javax.swing.DefaultButtonModel.setPressed(DefaultButtonModel.java:242)at javax.swing.plaf.basic.BasicButtonListener.mouseReleased(BasicButtonListener.java:236)at java.awt.Component.processMouseEvent(Component.java:6263)at javax.swing.JComponent.processMouseEvent(JComponent.java:3267)at java.awt.Component.processEvent(Component.java:6028)at java.awt.Container.processEvent(Container.java:2041)at java.awt.Component.dispatchEventImpl(Component.java:4630)at java.awt.Container.dispatchEventImpl(Container.java:2099)at java.awt.Component.dispatchEvent(Component.java:4460)at java.awt.LightweightDispatcher.retargetMouseEvent(Container.java:4574)at java.awt.LightweightDispatcher.processMouseEvent(Container.java:4238)at java.awt.LightweightDispatcher.dispatchEvent(Container.java:4168)at java.awt.Container.dispatchEventImpl(Container.java:2085)at java.awt.Window.dispatchEventImpl(Window.java:2478)at java.awt.Component.dispatchEvent(Component.java:4460)at java.awt.EventQueue.dispatchEvent(EventQueue.java:599)at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:269)at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:184)at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:174)at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:169)at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:161)at java.awt.EventDispatchThread.run(EventDispatchThread.java:122)\nPlease using this api: StringTokenizer.nextToken.\nAnswer:"
}